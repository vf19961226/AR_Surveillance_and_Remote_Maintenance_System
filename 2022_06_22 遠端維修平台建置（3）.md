# 2022/06/22 遠端維修平台建置（3）
###### tags: `論文實做紀錄` `遠端平台` `霧節點` `AR使用者介面`

## 實作環境
1. **遠端平台**
遠端平台實作環境可參考[2022/06/10 遠端維修平台建置（1）的實作環境](https://hackmd.io/YBJrrhSrSLWTMjuhqslOzg?view#%E5%AF%A6%E4%BD%9C%E7%92%B0%E5%A2%83)。

2. **霧節點**
霧節點伺服器配置可參考[2022/06/18 霧節點伺服器建置（2）的霧節點實作環境](https://hackmd.io/eFlrRaF-QRm0ssr8H5-3pQ?view#%E5%AF%A6%E4%BD%9C%E7%92%B0%E5%A2%83)。

3. **AR設備**
AR設備環境與[2022/06/14 遠端維修平台建置（2）](https://hackmd.io/mbfGRJvuQZe632kesg2e0A?view#%E5%AF%A6%E4%BD%9C%E7%92%B0%E5%A2%83)相同。

## 實作紀錄
本次實作主要為紀錄與讀取標註記錄、資料庫查看介面、CNC模型同動等功能，這些功能將基於過去的實作成果進行開發，以下將一一詳述各功能之實作過程。

### 記錄與讀取標註記錄
本功能主要基於2022/06/10 遠端維修平台建置（1）所實作之物件控制中的[模型傳送](https://hackmd.io/YBJrrhSrSLWTMjuhqslOzg#%E5%AF%A6%E4%BD%9C%E7%B4%80%E9%8C%84)功能進行延伸，將打包好的XML檔案進行儲存，並且可重複調用。程式步驟如下所述。

1. **記錄XML檔案**
    利用2022/06/10 遠端維修平台建置（1）所實作之物件控制中的[模型傳送](https://hackmd.io/YBJrrhSrSLWTMjuhqslOzg#%E5%AF%A6%E4%BD%9C%E7%B4%80%E9%8C%84)功能中，以將XML檔案進行輸出至遠端電腦儲存，並將檔名儲存至資料庫，以利後續調用時可直接讀取檔案。將檔案寫入資料庫之程式如下所示。

    ```csharp=
    private void xml2sql(string file_path)
    {
        SqlConnection conn = model_manager2.clientSQL;

        string cmd = @"
                        USE Cloud_Database;
                        INSERT INTO Operate_Log(
                        [time], [file_name], [tag]
                        )
                        VALUES(
                        GETDATE(), '" + file_path + "', 'TEST');";

        SqlCommand dr = new SqlCommand(cmd, conn);
        dr.ExecuteNonQuery(); //表示受影響的列數
        dr.Cancel(); //關閉SqlCommand
    }
    ```
    
    於2022/06/10 遠端維修平台建置（1）以事先建置Socket通道，用以傳送XML封包至霧節點，霧節點接收XML封包後，先將其進行解碼並由字串輸入XML樹中（`ElementTree.ElementTree`），接著將其以現在時間作為檔名儲存至霧節點，並紀錄於資料庫中。程式如下所示。
    
    ```python=
    def bytes2xml(self, indata):
        data = indata.decode("utf-8")

        xml = minidom.parseString(data)
        xml_pretty_str = xml.toprettyxml()

        data = ET.ElementTree(ET.fromstring(xml_pretty_str))
        #self.queue2.put(data) #把XML資料傳到Image_Shading4
        self.read_xml(data)

        localtime = time.localtime()
        result = time.strftime("%Y%m%d%H%M%S", localtime)
        file_name = "log_" + result
        data.write(file_name + ".xml")
        self.xml2sql(file_name)

    def xml2sql(self, file_name): #把收到的XML存到資料庫
        file_name = "'" + file_name + "'"
        tag = "'This is a test.'"

        server = self.IP
        port = '1433'
        username = 'username'
        password = 'password' 
        cnxn = pyodbc.connect(driver='{ODBC Driver 17 for SQL Server}', server=server + ',' + port, user=username, password=password, autocommit=True)
        cursor = cnxn.cursor()

        cursor.execute('''
                        USE Fog_Database;
                        INSERT INTO Operate_Log (
                            time, file_name, tag)
                        VALUES(
                            GETDATE(),''' + file_name + "," + tag + ")"
                        )
        cursor.commit()

        # 斷開連線、釋放資源
        cursor.close()
        cnxn.close()

        print("有收到XML資料並儲存了")
    ```

2. **讀取XML檔案**
    遠端平台中透過直接讀取XML檔案進行匯入標註資訊，直接讀取`Model_Data/Number`之節點所有資訊，並直接讀取標註模型之位置、大小、旋轉角度等資訊，將依據其模型種類代碼進行生成標註模型，0代表箭頭、1代表手、2代表注意、3代表白板。程式如下示。
        
    ```csharp=
    private void xml_import() //匯入XML檔紀錄的模型資訊
    {
        string file_path = model_manager2.select_xml_file;

        if (file_path != null)
        {
            string xml_path = "XML_File/" + file_path + ".xml";

            XmlDocument doc = new XmlDocument();
            doc.Load(xml_path);
            XmlNode xmlRoot = doc.DocumentElement;

            foreach (XmlNode node in xmlRoot.SelectNodes("Model_Data/Number")) //讀取XML檔中所有Model_Data/Number節點
            {
                string Location = node.SelectSingleNode("Location").InnerText;
                string Size = node.SelectSingleNode("Size").InnerText;
                string Rotation_Angle = node.SelectSingleNode("Rotation_Angle").InnerText;

                switch (node.SelectSingleNode("Type").InnerText)
                {
                    case "0":
                        load_model(model0, Location, Size, Rotation_Angle);
                        break;
                    case "1":
                        load_model(model1, Location, Size, Rotation_Angle);
                        break;
                    case "2":
                        load_model(model2, Location, Size, Rotation_Angle);
                        break;
                    case "3":
                        load_model(model3, Location, Size, Rotation_Angle);
                        break;
                }
            }

            model_manager2.select_xml_file = null;
        }

    }

    private void load_model(GameObject obj, string loca, string size, string rotate)
    {
        loca = loca.Replace("(", "").Replace(")", "");
        string[] locas = loca.Split(','); //注意""(string)和''(char)不一樣

        size = size.Replace("(", "").Replace(")", "");
        string[] sizes = size.Split(',');

        rotate = rotate.Replace("(", "").Replace(")", "");
        string[] rotates = rotate.Split(',');

        GameObject new_obj = Instantiate(obj, new Vector3(float.Parse(locas[0]), float.Parse(locas[1]), float.Parse(locas[2])), new Quaternion(float.Parse(rotates[0]), float.Parse(rotates[1]), float.Parse(rotates[2]), float.Parse(rotates[3])));
        new_obj.transform.localScale = new Vector3(float.Parse(sizes[0]), float.Parse(sizes[1]), float.Parse(sizes[2]));
    }
    ```


3. **遠端標註渲染**
    讀取前述收到的XML封包中的`Model_Data/Number`節點下之所有標註模型資訊，如模型種類、位置、大小、旋轉角度等資訊，並將這些資訊傳送至影像渲染模組進行渲染。

    ```python=
    def string_split(self, text):
        text = text.strip('(')
        text = text.strip(')')
        arr = text.split(', ')
        arr = [float(i) for i in arr]

        return arr

    def read_xml(self, data):
        model_info = []

        root = data.getroot()
        obj = root.findall('Model_Data/Number')
        for i in obj:
            Type = int(i[0].text)
            Loc = self.string_split(i[1].text)
            Size = self.string_split(i[2].text)
            Rota = self.string_split(i[3].text)

            info = {'Type': Type, 'Loc': Loc, 'Size': Size, 'Rota': Rota}
            model_info.append(info)

        self.queue2.put(model_info)
    ```
    
    在影像渲染模組中，透過讀取示先匯入之標註模型，並對其位置、大小、旋轉角度進行轉換與調整，將其由Unity座標轉換為OpenGL座標，使模型渲染於正確位置上，如下圖所示。程式如下所示。

    ![遠端標註](https://i.imgur.com/WiPr4mR.png)

    
    ```python= 
    def load_xml_data(self, data, modelView, projection): #渲染來自XML檔案的標註資訊
        for i in data:
            Type = i['Type']
            Loc = i['Loc']
            Size = i['Size']
            Rota = i['Rota']

            glMatrixMode(GL_PROJECTION)
            glLoadIdentity()
            glMultMatrixf(projection)

            glMatrixMode(GL_MODELVIEW)
            glLoadIdentity()
            glLoadMatrixf(modelView)

            glTranslatef((Loc[0] + 0.65)*12, (Loc[1] - 0.775)*17, (Loc[2] - 1.4)*(-4)) #（這個函式是移動模型位置的）#須注意與Unity空間座標的換算 X = (X+0.65)*12 Y = (Y-0.775)*17 Z = (Z-1.4)(-4)
            glRotatef(180, 1, 0, 0);
            glRotatef(Rota[0], 1, 0, 0);
            glRotatef(Rota[1], 0, 1, 0);
            glRotatef(Rota[2], 0, 0, 1);

            glEnable(GL_LIGHT0)
            glCallList(Type + 1) #呼叫示先匯入的模型，並變更為前面設定的狀態
            glDisable(GL_LIGHT0)
    ```

### 資料庫查看介面
於Unity中建立一彈出視窗，將資料庫之資料顯示於視窗中，讓遠端專家可透過該視窗查看CNC感測數據，以及過去之標註資料，並且可透過選擇標註資廖重複使用，以降低遠端人員標註的時間。資料庫查看介面如下圖所示。程式步驟如下所述。

![資料庫查看介面](https://i.imgur.com/xI7k02W.png)

1. **建立平面**
    使用Unity UI中的Panel（平面）作為顯示資料的平面，於平面中再加入兩個子平面作為顯示CNC感測資料（CNC Sensing Data）以及標註資料（Operate Log）的平面，並於其中加入遮罩與滾動條（Scroll Bar）製作出視窗瀏覽效果，另外於平面中加入切換平面按鍵，以各平面的`SetActive`屬性控制顯示頁面，其中資料庫查看介面的顯示與關閉也是透過該屬性以按鍵（OK、Close）進行控制，程式如下所示。

    ```csharp=
    public void Panel_Show()
    {
        Panel.SetActive(true);
        model_manager2.DB_Panel_Show = true;
        model_manager2.model_type = -1; //相機移動功能關閉
    }

    public void Change_Page()
    {
        Text now_page = Page_Tag.GetComponent<Text>();

        if (now_page.text == "CNC Sensing Data")
        {
            now_page.text = "Operate Log";
            DB_Panel1.SetActive(false);
            DB_Panel2.SetActive(true);
        }
        else if (now_page.text == "Operate Log")
        {
            now_page.text = "CNC Sensing Data";
            DB_Panel2.SetActive(false);
            DB_Panel1.SetActive(true);
        }
    }

    public void Panel_Close()
    {
        model_manager2.DB_Panel_Show = false;
        Panel.SetActive(false);
    }

    public void Panel_OK()
    {
        model_manager2.DB_Panel_Show = false;
        Panel.SetActive(false);
    }
    ```

2. **建立資料陣列**
    為了使資料庫資料以表格方式呈現，以增加資料可讀性，將以陣列方式對資料庫讀取出來的資料進行排序，以克服Unity沒有表單UI的困境。陣列設定方式可參考《[【Unity3D】表格](https://blog.csdn.net/yongh701/article/details/70858083)》，利用Vertical Layout Group模組將Text進行陣列排序，並將Text顯示的文字事先設定為各行標頭，同時以其為基礎製作預製體（Prefab），以利後續資料顯示可以整齊排列，在本次實作中將Vertical Layout Group模組的間隔（Spacing）設為10。設定成果如下圖所示。

    ![資料陣列顯示設定](https://i.imgur.com/JrqnoBS.png)

3. **讀取資料**
    資料讀取使用與2022/06/18 霧節點伺服器建置（2）中的[資料庫查看介面](https://hackmd.io/eFlrRaF-QRm0ssr8H5-3pQ?view#%E8%B3%87%E6%96%99%E5%BA%AB%E6%9F%A5%E7%9C%8B%E4%BB%8B%E9%9D%A2)相似，而資料顯示將使用前述建置之資料陣列，將資料依序填入預製體中的Text，接著利用Vertical Layout Group模組進行排列。程式如下所示。

    ```csharp=
    void Start()
    {
        if (model_manager2.clientSQL == null)
        {
            conn = new SqlConnection("data source=" + SQL_Server_IP + "; user id =" + User_ID + "; password =" + Password);
            conn.Open();

            model_manager2.clientSQL = conn;
        }
    }

    public void Panel_Show()
    {
        Panel.SetActive(true);
        model_manager2.DB_Panel_Show = true;
        model_manager2.model_type = -1; //相機移動功能關閉

        //讀取
        string sql_cmd = @"
                          USE Cloud_Database;
                          SELECT * FROM CNC_Sensing_Data;
                          ";
        SqlCommand cmd = new SqlCommand(sql_cmd, conn);
        SqlDataReader dr = cmd.ExecuteReader();

        while (dr.Read())
        {
            GameObject row = GameObject.Instantiate(Row1, DB_Table1.transform.position, DB_Table1.transform.rotation);
            row.transform.SetParent(DB_Table1.transform);
            row.transform.localScale = Vector3.one;

            row.transform.Find("Cell0").GetComponent<Text>().text = dr["number"].ToString();
            row.transform.Find("Cell1").GetComponent<Text>().text = dr["time"].ToString();
            row.transform.Find("Cell2").GetComponent<Text>().text = dr["x_vibration"].ToString();
            row.transform.Find("Cell3").GetComponent<Text>().text = dr["y_vibration"].ToString();
            row.transform.Find("Cell4").GetComponent<Text>().text = dr["z_vibration"].ToString();
            row.transform.Find("Cell5").GetComponent<Text>().text = dr["s_current"].ToString();
            row.transform.Find("Cell6").GetComponent<Text>().text = dr["x_loc"].ToString();
            row.transform.Find("Cell7").GetComponent<Text>().text = dr["y_loc"].ToString();
            row.transform.Find("Cell8").GetComponent<Text>().text = dr["z_loc"].ToString();
            row.transform.Find("Cell9").GetComponent<Text>().text = dr["x_velocity"].ToString();
            row.transform.Find("Cell10").GetComponent<Text>().text = dr["y_velocity"].ToString();
            row.transform.Find("Cell11").GetComponent<Text>().text = dr["z_velocity"].ToString();
            row.transform.Find("Cell12").GetComponent<Text>().text = dr["x_torque"].ToString();
            row.transform.Find("Cell13").GetComponent<Text>().text = dr["y_torque"].ToString();
            row.transform.Find("Cell14").GetComponent<Text>().text = dr["z_torque"].ToString();
            row.transform.Find("Cell15").GetComponent<Text>().text = dr["x_errcode"].ToString();
            row.transform.Find("Cell16").GetComponent<Text>().text = dr["y_errcode"].ToString();
            row.transform.Find("Cell17").GetComponent<Text>().text = dr["z_errcode"].ToString();
            row.transform.Find("Cell18").GetComponent<Text>().text = dr["Alarm"].ToString();

            cnc_table.Add(row);
        }
        dr.Close();

        //讀取Operate_Log
        sql_cmd = @"
                          USE Cloud_Database;
                          SELECT * FROM Operate_Log;
                          ";
        cmd = new SqlCommand(sql_cmd, conn);
        dr = cmd.ExecuteReader();

        while (dr.Read())
        {
            GameObject row = GameObject.Instantiate(Row2, DB_Table2.transform.position, DB_Table2.transform.rotation);
            row.transform.SetParent(DB_Table2.transform);
            row.transform.localScale = Vector3.one;

            row.transform.Find("Cell0").GetComponent<Text>().text = dr["number"].ToString();
            row.transform.Find("Cell1").GetComponent<Text>().text = dr["time"].ToString();
            row.transform.Find("Cell2").GetComponent<Text>().text = dr["file_name"].ToString();
            row.transform.Find("Cell3").GetComponent<InputField>().text = dr["tag"].ToString();

            string file_name = dr["file_name"].ToString();
            for (int i = 0; i <= 3; i++) //加入按鈕
            {
                Button image_button = row.transform.Find("Cell" + i + "/RawImage" + i).GetComponent<Button>();
                image_button.onClick.AddListener(delegate { select_data(file_name); });
            }

            operate_table.Add(row);
        }
        dr.Close();
    }
    ```

4. **選取資料**
透過於標註資料頁面中加入的資料附加按鈕物件，讓使用者可直接於介面中選擇欲匯入的XML標註資料，並按下OK進行資料匯入，使標註模型顯示於介面中。其中加入按鈕之程式已於前一步驟之程式碼中，讀取之程式於前述之讀取XML檔案中，故這邊不再重複敘述。

### CNC模型同動
CNC模型同動將基於[2022/06/10 遠端維修平台建置（1）](https://hackmd.io/YBJrrhSrSLWTMjuhqslOzg?view#%E5%AF%A6%E4%BD%9C%E7%B4%80%E9%8C%84)所建置之CNC模型進行實作，將使用Socket接收來自霧節點之CNC位置資訊，將其經過座標轉換之後，利用個軸模型之`transform.position`屬性進行位置控制，座標轉換公式與參數如下所示。程式可直接參考程式碼整理。

$$ Loc_{Model} = -(Loc_{CNC} \times \alpha + \beta) $$

|參數名稱|參數意義|參數設定
|:---:|:---:|:---
|$Loc_{Model}$|各軸於同動模型中的位置|-
|$Loc_{CNC}$|各軸於實體機台中的位置|-
|$\alpha$|實體機台與同動模型的縮放比例|0.001
|$\beta$|各軸於同動模型上的原點位置|X軸：-0.42<br>Y軸：0<br>Z軸：-0.275

## 程式碼整理
### 記錄與讀取標註記錄
1. 遠端平台
    ```csharp=
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    using System.Xml;
    using System.Xml.Serialization;
    using System;
    using System.Text;

    using System.Data.SqlClient;
    using System.IO;

    public class TRS_model : MonoBehaviour
    {
        public string model_type;
        public GameObject X_Axis;
        public GameObject Y_Axis;
        public GameObject Z_Axis;

        // Start is called before the first frame update
        void Start()
        {

        }

        // Update is called once per frame
        void Update()
        {

        }

        private void show_handle() //之後可利用GetHandleSize確保手把大小一致
        {
            if (model_manager2.model_id != null)
            {
                GameObject model = model_manager2.model_id;

                GameObject X = Instantiate(X_Axis, model.transform.position, model.transform.rotation);
                X.transform.localScale = model.transform.localScale;

                GameObject Y = Instantiate(Y_Axis, model.transform.position, model.transform.rotation);
                Y.transform.localScale = model.transform.localScale;

                GameObject Z = Instantiate(Z_Axis, model.transform.position, model.transform.rotation);
                Z.transform.localScale = model.transform.localScale;

                model_manager2.handle_show = true;
                model_manager2.X_show = X;
                model_manager2.Y_show = Y;
                model_manager2.Z_show = Z;

                model.transform.GetComponent<Collider>().enabled = false; //關閉該物體的碰撞器
            }
        }

        private void destroy_handle()
        {
            Destroy(model_manager2.X_show);
            Destroy(model_manager2.Y_show);
            Destroy(model_manager2.Z_show);
            model_manager2.X_show = null;
            model_manager2.Y_show = null;
            model_manager2.Z_show = null;

            model_manager2.handle_id = null;
        }

        public void btn_OnClick()
        {
            if (model_manager2.handle_show == false) //確認物件移動手把沒有被顯示
            {
                show_handle();
                if (model_type == "T") model_manager2.model_type = 1;
                else if (model_type == "R") model_manager2.model_type = 2;
                else if (model_type == "S") model_manager2.model_type = 3;
            }
            else //如果把手已經顯示
            {
                destroy_handle(); //銷毀上一個把手
                show_handle(); //重新繪製把手
                if (model_type == "T" && model_manager2.model_type != 1)
                {
                    model_manager2.model_type = 1;
                }
                else if (model_type == "R" && model_manager2.model_type != 2)
                {
                    model_manager2.model_type = 2;
                }
                else if (model_type == "S" && model_manager2.model_type != 3)
                {
                    model_manager2.model_type = 3;
                }
            }

        }

        public void distory()
        {
            if (model_manager2.model_id != null)
            {
                Destroy(model_manager2.model_id);
                model_manager2.model_id = null;
                destroy_handle();
            }
        }

        public void send_model() //發送標註資訊
        {
            GameObject[] model_list;
            model_list = GameObject.FindGameObjectsWithTag("Annotation");

            XmlDocument send_data = new XmlDocument();
            XmlElement annotation_data = send_data.CreateElement("Annotation_Data");
            send_data.AppendChild(annotation_data);

            XmlElement information = send_data.CreateElement("Information");
            annotation_data.AppendChild(information);

            XmlElement creator = send_data.CreateElement("Creator");
            creator.InnerText = "Hong-Yuan Yang";
            information.AppendChild(creator);

            XmlElement time = send_data.CreateElement("Time");
            time.InnerText = DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss");
            information.AppendChild(time);

            XmlElement target = send_data.CreateElement("Target");
            target.InnerText = "NCKU IMILab CNC";
            information.AppendChild(target);

            XmlElement model_data = send_data.CreateElement("Model_Data");
            annotation_data.AppendChild(model_data);

            int i = 0;
            foreach (GameObject model in model_list)
            {
                string name = model.name;
                Vector3 position = model.transform.transform.position;
                Quaternion rotate = model.transform.rotation;
                Vector3 scale = model.transform.localScale;

                XmlElement number = send_data.CreateElement("Number");
                number.SetAttribute("Number", Convert.ToString(i));//設定屬性
                model_data.AppendChild(number);

                XmlElement type = send_data.CreateElement("Type");
                type.InnerText = model_name2type(name);
                number.AppendChild(type);

                XmlElement location = send_data.CreateElement("Location");
                location.InnerText = Convert.ToString(position);
                number.AppendChild(location);

                XmlElement size = send_data.CreateElement("Size");
                size.InnerText = Convert.ToString(scale);
                number.AppendChild(size);

                XmlElement rotation_angle = send_data.CreateElement("Rotation_Angle");
                rotation_angle.InnerText = Convert.ToString(rotate);
                number.AppendChild(rotation_angle);

                i++;
            }
            Directory.CreateDirectory("XML_File"); //創建儲存XML檔案的資料夾

            string file_name = "log_" + DateTime.Now.ToString("yyyyMMddHHmmss");
            send_data.Save("XML_File/" + file_name + ".xml"); //儲存XML檔
            xml2sql(file_name);

            byte[] send = Encoding.UTF8.GetBytes(send_data.OuterXml);
            model_manager2.clientSocket.Send(send);
        }

        private void xml2sql(string file_path)
        {
            Debug.Log(file_path);
            SqlConnection conn = model_manager2.clientSQL;

            string cmd = @"
                            USE Cloud_Database;
                            INSERT INTO Operate_Log(
                            [time], [file_name], [tag]
                            )
                            VALUES(
                            GETDATE(), '" + file_path + "', 'TEST');";

            SqlCommand dr = new SqlCommand(cmd, conn);
            dr.ExecuteNonQuery();
            dr.Cancel();
        }

        private string model_name2type(string name)
        {
            string type = "";
            switch (name)
            {
                case "Arrow Variant(Clone)":
                    type = "0";
                    break;

                case "hand2 Variant(Clone)":
                    type = "1";
                    break;

                case "Notice Variant(Clone)":
                    type = "2";
                    break;

                case "Whiteboard Variant(Clone)":
                    type = "3";
                    break;
            }
            return type;
        }
    }
    ```

2. 霧節點
```python=
#讀取
class Socket_Server2(Process): #給遠端平台用的
    def __init__(self, queue1, queue2, IP, PORT):
        super(Socket_Server2, self).__init__() #需要繼承父類別的的東東
        
        self.queue1 = queue1
        self.queue2 = queue2
        
        self.IP = IP
        self.PORT = PORT
        
        self.server_init()
        
        #print("Socket Init")
        
    def server_init(self):
        self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        self.s.bind((self.IP, self.PORT))
        self.s.listen(5)
        
    def string_split(self, text):
        text = text.strip('(')
        text = text.strip(')')
        arr = text.split(', ')
        arr = [float(i) for i in arr]
        
        return arr
        
    def read_xml(self, data):
        model_info = []
        
        root = data.getroot()
        obj = root.findall('Model_Data/Number')
        for i in obj:
            Type = int(i[0].text)
            Loc = self.string_split(i[1].text)
            Size = self.string_split(i[2].text)
            Rota = self.string_split(i[3].text)
            
            info = {'Type': Type, 'Loc': Loc, 'Size': Size, 'Rota': Rota}
            model_info.append(info)
            
        self.queue2.put(model_info) #把XML資料傳到Image_Shading4
        
    def bytes2xml(self, indata):
        data = indata.decode("utf-8")
        
        xml = minidom.parseString(data)
        xml_pretty_str = xml.toprettyxml()
        
        data = ET.ElementTree(ET.fromstring(xml_pretty_str))
        #self.queue2.put(data) #把XML資料傳到Image_Shading4
        self.read_xml(data)
        
        localtime = time.localtime()
        result = time.strftime("%Y%m%d%H%M%S", localtime)
        file_name = "log_" + result
        data.write(file_name + ".xml")
        self.xml2sql(file_name)
            
    def xml2sql(self, file_name): #把收到的XML存到資料庫
        file_name = "'" + file_name + "'"
        tag = "'This is a test.'"
    
        server = self.IP
        port = '1433'
        username = 'username' 
        password = 'password' 
        cnxn = pyodbc.connect(driver='{ODBC Driver 17 for SQL Server}', server=server + ',' + port, user=username, password=password, autocommit=True)
        cursor = cnxn.cursor()

        cursor.execute('''
                        USE Fog_Database;
                        INSERT INTO Operate_Log (
                            time, file_name, tag)
                        VALUES(
                            GETDATE(),''' + file_name + "," + tag + ")"
                        )
        cursor.commit()
        
        # 斷開連線、釋放資源
        cursor.close()
        cnxn.close()
        
        print("有收到XML資料並儲存了")
            
    def img2bytes(self):
        img = self.queue1.get(True)
        
        img_encode = cv2.imencode('.jpg', img)[1]
        data_encode = np.array(img_encode)
        str_encode = data_encode.tobytes()

        return str_encode

    def get_xml(self, conn):
        while 1:
            indata = conn.recv(2000000) #接收Remote Platform傳來的資料
            self.bytes2xml(indata)

    def run(self):
        print("Socket_Server2: {}".format(os.getpid()))
        while 1:
            conn, addr = self.s.accept()
            print('Connected by ' + str(addr))
            
            thread0 = Thread(target = self.get_xml, args = (conn,)) #創建接收XML資料的線程，不然沒有傳XML資料的時候會卡住
            thread0.start()
            while 1:
                outdata = self.queue1.get(True)
                conn.send(outdata)

#渲染
import os
import numpy as np
from ctypes import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
from OpenGL.GL import *
from multiprocessing import Process

import objloader

class Image_Shading(Process):
    def __init__(self, queue1, queue2, queue3, queue4, queue5, img_width, img_height, test = False):
        super(Image_Shading, self).__init__() #需要繼承父類別的的東東
        
        self.queue1 = queue1
        self.queue2 = queue2
        self.queue3 = queue3
        self.queue4 = queue4 #SS42IS
        self.queue5 = queue5 #SS32IS
        
        self.xml_data = [] #Help模式的XML_DATA一開始是甚麼都沒有
        self.dashborads_before = None
        
        self.W = img_width
        self.H = img_height
        
        self.test = test #是否為本機測試模式
        
        self.help = False #是否為遠端協作模式
        
        #背景用的
        self.BG_VERTEX_SHADER = """   
                                #version 410
                                
                                layout(location = 0) in vec2 position;
                                layout(location = 1) in vec2 texcoord;
                                
                                out vec2 coord;
                                
                                void main()
                                {
                                	gl_Position = vec4(position, 0.0, 1.0);
                                	coord = texcoord;
                                }
                                """
                            
        self.BG_FRAGMENT_SHADER = """
                                #version 410
                                
                                in vec2 coord;
                                out vec4 color;
                                uniform sampler2D tex;
                                
                                void main(void)
                                {
                                	color = texture(tex, coord);
                                }
                                """
        
        #儀表板用的
        self.DB_VERTEX_SHADER = """
                                #version 410
                                
                                layout(location = 0) in vec2 position; //模型座標（x, y）
                                layout(location = 1) in vec2 texcoord; //貼圖座標（u, v）
                                
                                uniform vec3 translate;
                                uniform mat4 move;
                                uniform mat4 modelview;
                                uniform mat4 projection;
                                
                                out vec2 coord;
                                
                                void main()
                                {
                                    vec4 translate_model = vec4(position.x + translate.x, position.y + translate.y, 0.0 + translate.z, 1.0);
                                	gl_Position = projection * modelview * move * translate_model;
                                	coord = texcoord;
                                }
                                """
                            
        self.DB_FRAGMENT_SHADER = """
                                #version 410
                                
                                in vec2 coord;
                                out vec4 color;
                                uniform sampler2D tex; //貼圖（圖像）
                                
                                void main(void)
                                {
                                	color = texture(tex, coord);
                                }
                                """
                                
    def background_init(self):
        glClearColor(1.0, 1.0, 1.0, 1.0)
        glEnable(GL_DEPTH_TEST)
        glDepthFunc(GL_LEQUAL)
        
        # Initialize shaders
        ########################
        self.bg_program = glCreateProgram()
         
        bg_vs = glCreateShader(GL_VERTEX_SHADER)
        bg_fs = glCreateShader(GL_FRAGMENT_SHADER)
        
        glShaderSource(bg_vs, self.BG_VERTEX_SHADER)
        glShaderSource(bg_fs, self.BG_FRAGMENT_SHADER)
        
        glCompileShader(bg_vs)
        glCompileShader(bg_fs)
        
        glAttachShader(self.bg_program, bg_vs)
        glAttachShader(self.bg_program, bg_fs)
        
        glLinkProgram(self.bg_program)
         
        #glUseProgram(program)
        
        # Define vertex
        ########################       
        data = np.array([[1.0, -1.0, 1.0, 0.0],
                         [-1.0, -1.0, 0.0, 0.0],
                         [-1.0, 1.0, 0.0, 1.0],
                         [1.0, 1.0, 1.0, 1.0]], dtype = "float32") #[世界座標X軸, 世界座標Y軸, 視窗座標X軸, 視窗座標Y軸]
        
        data = data.flatten()
        
        # Create buffer
        ########################
        bg_buffer = glGenBuffers(1)
        
        glBindBuffer(GL_ARRAY_BUFFER, bg_buffer)
        
        glBufferData(GL_ARRAY_BUFFER, data.nbytes, data, GL_STATIC_DRAW)
        
        self.bg_vao = glGenVertexArrays(1)
        glBindVertexArray(self.bg_vao)
        
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 16, None)
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 16, c_void_p(8)) #位移一個元素4bit，共為一9個元素36bit，型別要用ctypes的c_void_p
        
        glEnableVertexAttribArray(0)
        glEnableVertexAttribArray(1)
        
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    
        self.bg_texture = glGenTextures(1)
        glBindTexture(GL_TEXTURE_2D, self.bg_texture)
        
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
        
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, self.W, self.H, 0, GL_RGBA, GL_UNSIGNED_BYTE, None) #######這裡貼圖的長寬須注意（儀錶板）
    
        glBindTexture(GL_TEXTURE_2D, 0)
        glBindVertexArray(0)
            
    def draw_background(self, img): #渲染背景
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        
        glUseProgram(self.bg_program)
        glBindVertexArray(self.bg_vao)
        
        glBindTexture(GL_TEXTURE_2D, self.bg_texture) #1是背景的貼圖渲染器
        glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, self.W, self.H, GL_RGBA, GL_UNSIGNED_BYTE, img)
        glDrawArrays(GL_TRIANGLE_FAN, 0, 4)
        glClear(GL_DEPTH_BUFFER_BIT)
        glBindTexture(GL_TEXTURE_2D, 0) #0是內建的，用來取消綁定貼圖
        glBindVertexArray(0) #0是內建的，用來取消綁定VAO
        
        glUseProgram(0)
        
    def dashborad_init(self): #儀表板緩衝器初始化
        glClearColor(1.0, 1.0, 1.0, 1.0)
        glEnable(GL_DEPTH_TEST)
        glDepthFunc(GL_LEQUAL)
        
        # Initialize shaders
        ########################
        self.db_program = glCreateProgram()
         
        db_vs = glCreateShader(GL_VERTEX_SHADER)
        db_fs = glCreateShader(GL_FRAGMENT_SHADER)
        
        glShaderSource(db_vs, self.DB_VERTEX_SHADER)
        glShaderSource(db_fs, self.DB_FRAGMENT_SHADER)
        
        glCompileShader(db_vs)
        glCompileShader(db_fs)
        
        glAttachShader(self.db_program, db_vs)
        glAttachShader(self.db_program, db_fs)
        
        glLinkProgram(self.db_program)
        
        glUseProgram(self.db_program)
        
        self.translate = glGetUniformLocation(self.db_program, "translate")
        self.move = glGetUniformLocation(self.db_program, "move")
        self.model_view = glGetUniformLocation(self.db_program, "modelview")
        self.projection = glGetUniformLocation(self.db_program, "projection")
        
        glUseProgram(0)
        
        # Define vertex
        ######################## 之後需要更換頂點座標位置（？
        data = np.array([[0.5, -0.5, 1.0, 0.0],
                         [-0.5, -0.5, 0.0, 0.0],
                         [-0.5, 0.5, 0.0, 1.0],
                         [0.5, 0.5, 1.0, 1.0]], dtype = "float32") #[世界座標X軸, 世界座標Y軸, 視窗座標X軸, 視窗座標Y軸] [頂點座標X, 頂點座標Y, 貼圖座標X, 貼圖座標Y]
        
        data = data.flatten()
        
        # Create buffer
        ########################
        db_buffer = glGenBuffers(1)
        
        glBindBuffer(GL_ARRAY_BUFFER, db_buffer)
        
        glBufferData(GL_ARRAY_BUFFER, data.nbytes, data, GL_STATIC_DRAW)
        
        self.db_vao = glGenVertexArrays(1)
        glBindVertexArray(self.db_vao)
        
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 16, None)
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 16, c_void_p(8)) #位移一個元素4bit，共為一9個元素36bit，型別要用ctypes的c_void_p
        
        glEnableVertexAttribArray(0)
        glEnableVertexAttribArray(1)
        
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    
        self.db_texture = glGenTextures(1)
        glBindTexture(GL_TEXTURE_2D, self.db_texture)
        
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR)
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR)
        
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, 640, 480, 0, GL_RGBA, GL_UNSIGNED_BYTE, None) ###這裡需先知道儀表板的大小（長跟寬）
    
        glBindTexture(GL_TEXTURE_2D, 0)
        glBindVertexArray(0)
        
    def model_rotate_scaling(self, theta, axis, a = 1, b = 1, c = 1): #調整位置、大小、旋轉
        opt_matrix = np.eye(4) #opt_matrix初始化
        
        scaling = np.array([[a, 0, 0, 0],
                                 [0, b, 0, 0],
                                 [0, 0, c, 0],
                                 [0, 0, 0, 1]], dtype = "float32")
        
        for t, a in zip(theta, axis):
            t = t * np.pi / 180 #轉成弧度
            if a == 0:
                rotate = np.array([[1, 0, 0, 0],
                                   [0, np.cos(t), -np.sin(t), 0],
                                   [0, np.sin(t), np.cos(t), 0],
                                   [0, 0, 0, 1]], dtype = "float32")
                
            elif a == 1:
                rotate = np.array([[np.cos(t), 0, np.sin(t), 0],
                                   [0, 1, 0, 0],
                                   [-np.sin(t), 0, np.cos(t), 0],
                                   [0, 0, 0, 1]], dtype = "float32")
                
            elif a == 2:
                rotate = np.array([[np.cos(t), -np.sin(t), 0, 0],
                                   [np.sin(t), np.cos(t), 0, 0],
                                   [0, 0, 1, 0],
                                   [0, 0, 0, 1]], dtype = "float32")
                
            opt_matrix = np.dot(rotate, opt_matrix)
            
        opt_matrix = np.dot(scaling, opt_matrix)
        
        opt_matrix = np.linalg.inv(opt_matrix)
        
        return opt_matrix.flatten()
        
    def draw_dashborad(self, modelView, Projection): #渲染儀表板
        dashborads = None
    
        if self.queue3.empty() != True:
            dashborads = self.queue3.get(True)
            self.dashborads_before = dashborads
        else:
            dashborads = self.dashborads_before
        
        dashborads_list = ["S", "X", "Y", "Z"]
        
        for i in dashborads_list:
            dashborad = dashborads[i]
            
            glUseProgram(self.db_program)
            glBindVertexArray(self.db_vao)
            
            glBindTexture(GL_TEXTURE_2D, self.db_texture) #1是背景的貼圖渲染器
            glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 640, 480, GL_RGBA, GL_UNSIGNED_BYTE, dashborad)

            if i == "S":
                glUniform3fv(self.translate, 1, np.array([0, 0, 0], dtype = "float32").flatten()) #平移[x, y, z]
            elif i == "X":
                glUniform3fv(self.translate, 1, np.array([0, -1.5, 0], dtype = "float32").flatten()) #平移[x, y, z]
            elif i == "Y":
                glUniform3fv(self.translate, 1, np.array([-1.5, 0, 0], dtype = "float32").flatten()) #平移[x, y, z]
            elif i == "Z":
                glUniform3fv(self.translate, 1, np.array([-1.5, -1.5, 0], dtype = "float32").flatten()) #平移[x, y, z]
                
            glUniformMatrix4fv(self.move, 1, GL_FALSE, self.model_rotate_scaling([0], [0], a = 0.5, b = 0.5))#調整大小
            glUniformMatrix4fv(self.model_view, 1, GL_FALSE, modelView)
            glUniformMatrix4fv(self.projection, 1, GL_FALSE, Projection)
            
            glDrawArrays(GL_TRIANGLE_FAN, 0, 4)
            
            glBindTexture(GL_TEXTURE_2D, 0) #0是內建的，用來取消綁定貼圖
            
            glBindVertexArray(0)
            glUseProgram(0)
            
    def draw_obj(self, modelView, projection): #渲染虛擬物件
        # 畫箭頭
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        glMultMatrixf(projection)
    
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()
        glLoadMatrixf(modelView)
        
        glTranslatef(6.8, 1, 0) #（這個函式是移動模型位置的）
        glRotatef(90, 0, 0, 1);
                
        glEnable(GL_LIGHT0)
        glCallList(1)
        glDisable(GL_LIGHT0)
        
        #畫手
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        glMultMatrixf(projection)
    
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()
        glLoadMatrixf(modelView)
        
        glTranslatef(3, -3, 1.5) #（這個函式是移動模型位置的）
        glRotatef(180, 1, 0, 0);
                
        glEnable(GL_LIGHT0)
        glCallList(2)
        glDisable(GL_LIGHT0)
        
        #畫注意
        glMatrixMode(GL_PROJECTION)
        glLoadIdentity()
        glMultMatrixf(projection)
    
        glMatrixMode(GL_MODELVIEW)
        glLoadIdentity()
        glLoadMatrixf(modelView)
        
        glTranslatef(3, 0, 3) #（這個函式是移動模型位置的）
        glRotatef(180, 0, 0, 1);
                
        glEnable(GL_LIGHT0)
        glCallList(3)

    def load_xml_data(self, data, modelView, projection): #渲染來自XML檔案的標註資訊
        for i in data:
            Type = i['Type']
            Loc = i['Loc']
            Size = i['Size']
            Rota = i['Rota']
            
            glMatrixMode(GL_PROJECTION)
            glLoadIdentity()
            glMultMatrixf(projection)
        
            glMatrixMode(GL_MODELVIEW)
            glLoadIdentity()
            glLoadMatrixf(modelView)
            
            glTranslatef(Loc[0] + 0.65, Loc[1] - 0.775, Loc[2] - 1.4) #（這個函式是移動模型位置的）#須注意與Unity空間座標的換算 X = (X+0.65)*12 Y = (Y-0.775)*17 Z = (Z-1.4)(-4)
            glRotatef(180, 1, 0, 0);
            glRotatef(Rota[0], 1, 0, 0);
            glRotatef(Rota[1], 0, 1, 0);
            glRotatef(Rota[2], 0, 0, 1);
            
            glEnable(GL_LIGHT0)
            glCallList(Type + 1)
            glDisable(GL_LIGHT0)
            
    def optimg(self): #取得渲染完成影像
        img_data = glReadPixels(0, 0, self.W, self.H, GL_BGRA, GL_FLOAT)
        img_data = np.frombuffer(img_data, np.float32)
        img_data.shape = self.H, self.W, 4
        img_data = img_data[::-1, :]
        
        if self.test:
            self.queue2.put(img_data)
        else:
            self.queue2.put(img_data * 255)
            
    def light_init(self): #加燈光
        glLightfv(GL_LIGHT0, GL_AMBIENT, (0.5, 0.5, 0.5, 1.0)) #設置環境光的屬性，0號
        glLightfv(GL_LIGHT0, GL_DIFFUSE, (0.6, 0.6, 0.6, 1.0)) #設置環境光的散射屬性，0號
        glLightfv(GL_LIGHT0, GL_POSITION, (0.0, 0.0, 1.0, 1.0)) #設置環境光的位置，0號
        glEnable(GL_LIGHTING)
        glEnable(GL_LIGHT0)
        
    def Display(self): #渲染影像迴圈
        data = self.queue1.get(True) #接收渲染影像跟相機矩陣
        
        if self.queue5.empty() != True: 
            flag = self.queue5.get(True) #接收現在模式（有沒有按下Help）（渲染儀表板或是OBJ）
            self.help = flag
        
        #time1 = time.time()
        
        img = data["img"]
        modelView = data["mv"]
        projection = data["pj"]
        
        self.draw_background(img)
        #self.draw_obj(modelView, projection)
        
        if self.help: #如果按下Help
            #self.draw_obj(modelView, projection)
            if self.queue4.empty() != True:
                self.xml_data = self.queue4.get(True)

            if len(self.xml_data) == 3:
                self.draw_obj(modelView, projection)
            else:
                self.load_xml_data(self.xml_data, modelView, projection) #須注意與Unity空間座標的換算 X+0.65 Y-0.775 Z-1.4

        else:
            self.draw_dashborad(modelView, projection)
        
        self.optimg()
        
        #time2 = time.time()
        #print("影像渲染共花了 " + str(time2 - time1) + "秒")
        
        glutSwapBuffers()
        
    def run(self):
        print("Image_Shading: {}".format(os.getpid()))
        
        # Initialize GLUT and GLEW, then create a window.
        ############################
        glutInit()
        glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH)
        
        glutInitWindowPosition(100, 100)
        glutInitWindowSize(self.W, self.H)
        glutCreateWindow(b"Image of Augmented Reality") # You cannot use OpenGL functions before this line; The OpenGL context must be created first by glutCreateWindow()!
        
        glEnable(GL_COLOR_MATERIAL) #開啟上色功能
        
        self.light_init() #燈光初始化
        self.background_init() #畫背景的buffer初始化，包含一些頂點甚麼之類的
        self.dashborad_init() #畫儀表板的buffer初始化，包含一些頂點甚麼之類的
        
        # 事先匯入標註模型
        objloader.OBJ("./OBJ_File/Arrow2.obj", swapyz = True) #讀取OBJ檔案，並且把它弄成一個渲染程序輸出（glCallList編號為1）
        objloader.OBJ("./OBJ_File/hand2.obj", swapyz = True) #讀取OBJ檔案，並且把它弄成一個渲染程序輸出（glCallList編號為2）
        objloader.OBJ("./OBJ_File/Notice2.obj", swapyz = True) #讀取OBJ檔案，並且把它弄成一個渲染程序輸出（glCallList編號為3）
        objloader.OBJ("./OBJ_File/Whiteboard_Word.obj", swapyz = True) #讀取OBJ檔案，並且把它弄成一個渲染程序輸出（glCallList編號為4）
         
        #Register GLUT callback functions
        ############################
        glutDisplayFunc(self.Display)
        glutIdleFunc(self.Display)
        ############################
        
        # Enter main event loop.
        glutMainLoop()
```

### 資料庫查看介面
```csharp=
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

using System.Data;
using System.Data.SqlClient;

using System.Xml;

public class DB_Panel_Show : MonoBehaviour
{
    public GameObject Panel;
    public GameObject Page_Tag;
    public GameObject DB_Panel1;
    public GameObject DB_Panel2;
    public GameObject DB_Table1;
    public GameObject DB_Table2;
    public GameObject Row1;
    public GameObject Row2;

    public GameObject model0;
    public GameObject model1;
    public GameObject model2;
    public GameObject model3;

    public string SQL_Server_IP;
    public string User_ID;
    public string Password;

    private SqlConnection conn;
    public List<GameObject> cnc_table = new List<GameObject>(); //紀錄資料庫顯示資料的預制體
    public List<GameObject> operate_table = new List<GameObject>(); //紀錄資料庫顯示資料的預制體

    // Start is called before the first frame update
    void Start()
    {
        if (model_manager2.clientSQL == null)
        {
            conn = new SqlConnection("data source=" + SQL_Server_IP + "; user id =" + User_ID + "; password =" + Password);
            conn.Open();

            model_manager2.clientSQL = conn;
        }
    }

    // Update is called once per frame
    void Update()
    {

    }

    public void Panel_Show()
    {
        Panel.SetActive(true);
        model_manager2.DB_Panel_Show = true;
        model_manager2.model_type = -1; //相機移動功能關閉

        //讀取
        string sql_cmd = @"
                          USE Cloud_Database;
                          SELECT * FROM CNC_Sensing_Data;
                          ";
        SqlCommand cmd = new SqlCommand(sql_cmd, conn);
        SqlDataReader dr = cmd.ExecuteReader();

        while (dr.Read())
        {
            GameObject row = GameObject.Instantiate(Row1, DB_Table1.transform.position, DB_Table1.transform.rotation);
            row.transform.SetParent(DB_Table1.transform);
            row.transform.localScale = Vector3.one;

            row.transform.Find("Cell0").GetComponent<Text>().text = dr["number"].ToString();
            row.transform.Find("Cell1").GetComponent<Text>().text = dr["time"].ToString();
            row.transform.Find("Cell2").GetComponent<Text>().text = dr["x_vibration"].ToString();
            row.transform.Find("Cell3").GetComponent<Text>().text = dr["y_vibration"].ToString();
            row.transform.Find("Cell4").GetComponent<Text>().text = dr["z_vibration"].ToString();
            row.transform.Find("Cell5").GetComponent<Text>().text = dr["s_current"].ToString();
            row.transform.Find("Cell6").GetComponent<Text>().text = dr["x_loc"].ToString();
            row.transform.Find("Cell7").GetComponent<Text>().text = dr["y_loc"].ToString();
            row.transform.Find("Cell8").GetComponent<Text>().text = dr["z_loc"].ToString();
            row.transform.Find("Cell9").GetComponent<Text>().text = dr["x_velocity"].ToString();
            row.transform.Find("Cell10").GetComponent<Text>().text = dr["y_velocity"].ToString();
            row.transform.Find("Cell11").GetComponent<Text>().text = dr["z_velocity"].ToString();
            row.transform.Find("Cell12").GetComponent<Text>().text = dr["x_torque"].ToString();
            row.transform.Find("Cell13").GetComponent<Text>().text = dr["y_torque"].ToString();
            row.transform.Find("Cell14").GetComponent<Text>().text = dr["z_torque"].ToString();
            row.transform.Find("Cell15").GetComponent<Text>().text = dr["x_errcode"].ToString();
            row.transform.Find("Cell16").GetComponent<Text>().text = dr["y_errcode"].ToString();
            row.transform.Find("Cell17").GetComponent<Text>().text = dr["z_errcode"].ToString();
            row.transform.Find("Cell18").GetComponent<Text>().text = dr["Alarm"].ToString();

            cnc_table.Add(row);
        }
        dr.Close();

        //讀取Operate_Log
        sql_cmd = @"
                          USE Cloud_Database;
                          SELECT * FROM Operate_Log;
                          ";
        cmd = new SqlCommand(sql_cmd, conn);
        dr = cmd.ExecuteReader();

        while (dr.Read())
        {
            GameObject row = GameObject.Instantiate(Row2, DB_Table2.transform.position, DB_Table2.transform.rotation);
            row.transform.SetParent(DB_Table2.transform);
            row.transform.localScale = Vector3.one;

            row.transform.Find("Cell0").GetComponent<Text>().text = dr["number"].ToString();
            row.transform.Find("Cell1").GetComponent<Text>().text = dr["time"].ToString();
            row.transform.Find("Cell2").GetComponent<Text>().text = dr["file_name"].ToString();
            row.transform.Find("Cell3").GetComponent<InputField>().text = dr["tag"].ToString();

            string file_name = dr["file_name"].ToString();
            for (int i = 0; i <= 3; i++)
            {
                Button image_button = row.transform.Find("Cell" + i + "/RawImage" + i).GetComponent<Button>();
                image_button.onClick.AddListener(delegate { select_data(file_name); });
            }

            operate_table.Add(row);
        }
        dr.Close();
    }

    public void Clear_Table() //清除Table裡面的資料
    {
        foreach(GameObject obj in cnc_table)
        {
            Destroy(obj);
        }

        foreach (GameObject obj in operate_table)
        {
            Destroy(obj);
        }
    }

    public void Panel_Close()
    {
        model_manager2.select_xml_file = null;
        model_manager2.DB_Panel_Show = false;
        Clear_Table();
        Panel.SetActive(false);
    }

    public void Panel_OK() //清除場上所有模型，並導入所選擇的模型檔案資訊
    {
        model_manager2.DB_Panel_Show = false;
        Panel.SetActive(false);
        if (Page_Tag.GetComponent<Text>().text == "Operate Log")
        {
            //Debug.Log("到時候直接開啟已經準備好的XML檔!!"); //到時候用select_data選的檔案開啟
            xml_import(); //匯入XML檔紀錄的模型資訊
        }
        Clear_Table();
    }

    private void xml_import() //匯入XML檔紀錄的模型資訊
    {
        string file_path = model_manager2.select_xml_file;

        if (file_path != null)
        {
            string xml_path = "XML_File/" + file_path + ".xml";

            XmlDocument doc = new XmlDocument();
            doc.Load(xml_path);
            XmlNode xmlRoot = doc.DocumentElement;

            foreach (XmlNode node in xmlRoot.SelectNodes("Model_Data/Number")) //讀取XML檔中所有Model_Data/Number節點
            {
                string Location = node.SelectSingleNode("Location").InnerText;
                string Size = node.SelectSingleNode("Size").InnerText;
                string Rotation_Angle = node.SelectSingleNode("Rotation_Angle").InnerText;

                switch (node.SelectSingleNode("Type").InnerText)
                {
                    case "0":
                        load_model(model0, Location, Size, Rotation_Angle);
                        break;
                    case "1":
                        load_model(model1, Location, Size, Rotation_Angle);
                        break;
                    case "2":
                        load_model(model2, Location, Size, Rotation_Angle);
                        break;
                    case "3":
                        load_model(model3, Location, Size, Rotation_Angle);
                        break;
                }
            }

            model_manager2.select_xml_file = null;
        }
        
    }

    private void load_model(GameObject obj, string loca, string size, string rotate)
    {
        loca = loca.Replace("(", "").Replace(")", "");
        string[] locas = loca.Split(','); //注意""(string)和''(char)不一樣

        size = size.Replace("(", "").Replace(")", "");
        string[] sizes = size.Split(',');

        rotate = rotate.Replace("(", "").Replace(")", "");
        string[] rotates = rotate.Split(',');

        GameObject new_obj = Instantiate(obj, new Vector3(float.Parse(locas[0]), float.Parse(locas[1]), float.Parse(locas[2])), new Quaternion(float.Parse(rotates[0]), float.Parse(rotates[1]), float.Parse(rotates[2]), float.Parse(rotates[3])));
        new_obj.transform.localScale = new Vector3(float.Parse(sizes[0]), float.Parse(sizes[1]), float.Parse(sizes[2]));
    }

    public void Change_Page()
    {
        Text now_page = Page_Tag.GetComponent<Text>();

        if (now_page.text == "CNC Sensing Data")
        {
            now_page.text = "Operate Log";
            DB_Panel1.SetActive(false);
            DB_Panel2.SetActive(true);
        }
        else if (now_page.text == "Operate Log")
        {
            now_page.text = "CNC Sensing Data";
            DB_Panel2.SetActive(false);
            DB_Panel1.SetActive(true);
        }
    }

    public void select_data(string file_name)
    {
        Debug.Log(file_name);
        model_manager2.select_xml_file = file_name;
    }
}
```

### CNC模型同動
```csharp=
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

using System.Net; //Socket
using System.Net.Sockets; //Socket
using System.Threading; //多執行緒
using System.Text;
using System;

public class CNC_Loc_Sync : MonoBehaviour
{
    public string Server_IP;
    public int Server_PORT;

    public GameObject X_Axis; //沿X軸移動（在Unity中）
    public GameObject Y_Axis; //沿Z軸移動（在Unity中）
    public GameObject Z_Axis; //沿Y軸移動（在Unity中）

    private Socket clientSocket; //Socket Client物件
    private Thread threadSocket; //Socket的執行緒

    private float[] locs = { 0, 0, 0}; //紀錄CNC三軸位置
    private float[] before_locs = { 0, 0, 0 };
    private float[] before_locs_show = { 0, 0, 0 };

    private byte[] data = new byte[100];

    // Start is called before the first frame update
    void Start()
    {
        clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //創建一個Socket物件
        clientSocket.Connect(new IPEndPoint(IPAddress.Parse(Server_IP), Server_PORT)); //連線到Server

        threadSocket = new Thread(new ThreadStart(SocketReceive));
        threadSocket.Start();
    }

    // Update is called once per frame
    void Update()
    {
        try
        {
            locs = model_manager2.loc;
            X_Axis.transform.position = new Vector3(-(locs[0] * 0.001f - 0.42f), 0f, 0f);
            Y_Axis.transform.position = new Vector3(0f, 0f, -(locs[1] * 0.001f - 0.275f));
            Z_Axis.transform.position = new Vector3(-(locs[0] * 0.001f - 0.42f), -locs[2] * 0.001f, 0f);
        }
        catch
        {

        }
    }

    private void SocketReceive() //接收Server（Fog Node）傳過來的影像
    {
        while (true)
        {
            data = new byte[100];
            int count = clientSocket.Receive(data);

            string result = Encoding.ASCII.GetString(data);
            string[] results = result.Split(' ');
            //Debug.Log(results);
            if (results.Length == 3)
            {
                try
                {
                    model_manager2.loc[0] = float.Parse(results[0]);
                    model_manager2.loc[1] = float.Parse(results[1]);
                    model_manager2.loc[2] = float.Parse(results[2]);
                }
                catch
                {

                }
                
            }
        }
    }

    void OnApplicationQuit()
    {
        //關閉執行緒
        if (threadSocket != null)
        {
            threadSocket.Interrupt();
            threadSocket.Abort();
        }
        //最後關閉伺服器
        if (clientSocket != null) clientSocket.Close();
    }
}
```

## Reference
### 遠端平台資料庫查看介面
 * [【Unity】UI Scrollbar & Scroll Rect](https://jerrard-liu.blogspot.com/2015/09/Scrollbar-Rect.html)
 * [【Unity3D】公告栏与开始界面的布置](https://blog.csdn.net/yongh701/article/details/70168234)
 * [【Unity3D】表格](https://blog.csdn.net/yongh701/article/details/70858083)
 * [Unity-Ugui-如何製作彈跳視窗](http://13.231.129.69/2019/11/28/unity-ugui-%E5%A6%82%E4%BD%95%E8%A3%BD%E4%BD%9C%E5%BD%88%E8%B7%B3%E8%A6%96%E7%AA%97/)
 * [unity点击按钮，弹出image和Text做的弹出框](https://blog.csdn.net/Ciel_Y/article/details/105715450)
 * [2018.07.31(二) – 用Code綁定Button的OnClick事件](https://featherchung.wordpress.com/2018/07/31/2018-07-31%E4%BA%8C-%E7%94%A8code%E7%B6%81%E5%AE%9Abutton%E7%9A%84onclick%E4%BA%8B%E4%BB%B6/)

### 讀取標註紀錄
 * [How to assign OnClick for UI Button generated in runtime?](https://forum.unity.com/threads/how-to-assign-onclick-for-ui-button-generated-in-runtime.358974/)
 * [DateTime.Now 屬性](https://docs.microsoft.com/zh-tw/dotnet/api/system.datetime.now?view=net-6.0)
 * [自訂日期與時間格式字串](https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/custom-date-and-time-format-strings)
 * [C#中String类型转换为Vector3类型](https://blog.csdn.net/ZJ_____W/article/details/105206067)
 * [C# 讀取和解析 XML 檔案](https://www.delftstack.com/zh-tw/howto/csharp/how-to-read-and-parse-an-xml-file-in-csharp/)
 * [XmlNodeReader.Read 方法](https://docs.microsoft.com/zh-tw/dotnet/api/system.xml.xmlnodereader.read?view=net-6.0)
 * [C# 讀取XML文件的幾種方式](https://min.news/zh-tw/technique/56b1a1c5d8a8dfc4856a7f927e387370.html)
 * [如何在 C# 中把一個字串轉換為浮點數](https://www.delftstack.com/zh-tw/howto/csharp/how-to-convert-a-string-to-float-in-csharp/)
 * [如何在 C# 中建立資料夾](https://www.delftstack.com/zh-tw/howto/csharp/how-to-create-a-folder-in-csharp/)
* [Python 讀取、寫入 XML 格式檔案教學與範例](https://officeguide.cc/python-read-write-xml-format-file-tutorial-examples/)
* [自訂日期與時間格式字串](https://docs.microsoft.com/zh-tw/dotnet/standard/base-types/custom-date-and-time-format-strings)
* [Python如何優雅的格式化XML 【Python XML Format】](https://www.twblogs.net/a/5eeb7c01e3ae0757d21a80d4)
* [Python xml ElementTree from a string source? - Stack Overflow](https://stackoverflow.com/questions/647071/python-xml-elementtree-from-a-string-source)