# 2022/06/10 遠端維修平台建置（1）
###### tags: `論文實做紀錄` `遠端平台` `霧節點`
## 實作環境
### 遠端平台
|**項目**|**版本**|
|:---:|:---:|
|**Windows 11 教育版**|21H2|
|**Visual Studio Professional 2019**|16.11.8|
|**Unity**|2019.4.39f1|
|**NuGetForUnity**|3.0.5|
|**OpenCvSharp**|4.6.0.20220608|

<font color=#FF0000>**注意：**</font>因為需要使用到OpenCV的相關功能，但是Unity本身並沒有開源的OpenCV套件可以使用，故這次實作使用了C＃ .NET架構下常用的NuGet取得C＃版本的OpenCV套件 - OpenCvSharp，詳細操作方法可參考《[把 OpenCVSharp4 安裝進 Unity （含 Webcam 測試程式）](https://medium.com/@frank1314168/%E5%B0%87-opencvsharp4-%E8%A3%9D%E9%80%B2-unity-8906cb8f9543)》。

### 霧節點
霧節點實作環境可參考[2022/04/26 單機實現AR演算法（1）的實作環境](https://hackmd.io/wpSYJl26Rw-ScjVlzjYwYw?view#%E5%AF%A6%E4%BD%9C%E7%92%B0%E5%A2%83)。

## 實作紀錄
本次實作目的為建立遠端維修系統所使用的遠端介面，該介面將使用**Unity遊戲引擎**製作，其中使用Socket通訊界面與霧節點進行資料交換，藉此建立虛擬標註、現場AR影像監控等功能，往後將根據論文規劃加入語音通話、標註記錄查詢、CNC感測數據查詢、CNC模型同動等功能。目前介面實作成果如下圖所示。以下為本次實作之詳細步驟。

![遠端維修介面](https://i.imgur.com/fhPFx83.png)

1. **建立使用者介面**
   於Unity建立使用者介面都將建立於Canvas物件下，可透過於Hierarchy點選滑鼠右鍵或是由上方工具列中的GameObject進入UI選單中創建，並將其移動至欲擺放的位置。詳細可參考[Unity3D游戏设计与开发](https://www.books.com.tw/products/CN11698389)的第八章UGUI，或是自行上網尋找相關資源。

2. **模型生成與匯入**
   模型生成方式與[2022/05/25 單機實現AR演算法（6）的3D建模](https://hackmd.io/aDllCoDmRhOGshNJFO4Heg#3D%E5%BB%BA%E6%A8%A1)方法類似，在Unity中雖然也可以匯入OBJ格式的模型，但是需另外載入模型外觀紋理資料，而FBX模型則將全部包再一起方便使用，故本次實作的模型採用FBX格式匯入Unity進行使用，流程如下圖所示。

   ![模型生成流程](https://i.imgur.com/YDWg5fN.png)

   本研究除了CNC模型為廠商提供外，其餘模型皆須自行繪製或是尋求第三方提供。在下圖的四個模型中，僅有手部模型（Hand）為[Giimann於TURBOSQUID網站中提供](https://www.turbosquid.com/3d-models/3d-palm-model/268623)，其餘皆為使用Solid Works進行建模。

   ![標註用3D模型](https://i.imgur.com/0MvbPVc.png)

   在Unity要匯入模型可透過直接將模型拖曳至Unity的Assets中，或是於Assets中點選右鍵選擇Import New Assets進行模型匯入。在模型匯入之後，可將模型從Assets拖曳至Hierarchy中進行預製體（Prefab）的設定，當設定完成後將其拖曳回Assets就完成了，如下圖所示。預製體的主要作用為事先設定好模型資訊，在後續重複調用時就不用重新設定。本次實作的預製體參數設定如下表所示。

   ![預製體製作](https://i.imgur.com/Vfml6a4.png)

   |Name|Type|Position|Rotation|Scale
   |:---:|:---:|:---:|:---:|:---:
   |Arrow Variant|Arrow|（-0.1, 0.279, 0）|（0, 0, 0）|（3, 3, 3）
   |Hand Variant|Hand|（-0.1, 0.453, 0）|（0, 180, 0）|（2, 2, 2）
   |Notice Variant|Notice|（-0.1, 0.215, 0）|（0, 0, 0）|（0.5, 0.5, 0.5）
   |Whiteboard Variant|Whiteboard|（-0.1, 0.403, 0）|（0, 0, 0）|（0.65, 0.65, 0.65）

   CNC的虛擬模型因需要針對各軸不同位置去進行變化，故將模型拆解成基座（Base）、X軸（X_Axis）、Y軸（Y_Axis）、Z軸（Z_Axis）等四個部分，如下圖所示，並根據其位置關係將X軸與Y軸設定為基座的子物件，而Z軸為X軸的子物件，以方便後續針對實體CNC個軸位置進行相對的位移。

   ![CNC模型拆解](https://i.imgur.com/00bsK5B.png)

3. **事件腳本撰寫**
   在本次實作中將功能分為全域變數、物件生成、物件控制、物件鎖定、影像視窗控制、Socket Client等6個腳本，以方便後續維護以及掛載至不同的物件上。以下將詳述上述6個腳本的功能及其實現。

   1. **全域變數**
      全域變數主要用在各個腳本之間需要共同使用的變數，以方便各個腳本相互合作。變數及其意義如下所示。
      
        ```csharp=
        static class model_manager2
        {
            public static int model_type = 0; //目前的移動模式（0：移動世界座標、1：模型平移、2：模型旋轉、3：模型縮放）
            public static GameObject model_id = null; //目前鎖定的標註物件
            public static GameObject handle_id = null; //目前鎖定的手把物件
            public static bool handle_show = false; //是否已經顯示物件移動手把

            public static GameObject X_show = null; //目前顯示的手把X軸物件
            public static GameObject Y_show = null; //目前顯示的手把Y軸物件
            public static GameObject Z_show = null; //目前顯示的手把Z軸物件

            public static Socket clientSocket; //Socket Client物件
        }
        ```
   
   2. **物件生成**
       此腳本主要用於生成標註物件的按鈕上，可透過變數`model`傳入欲顯示的標註物件，並將`btn_OnClick`函式綁定至按鈕的觸發事件中。在`btn_OnClick`函式中先確認是否有標註物件被鎖定，若有則將其物體的碰撞體開啟，以方便後續可以透過射線檢測碰撞體進行鎖定。接著以`Instantiate()`函式生成模型，並將其生成位置以及旋轉角度射為原始模型的數值，之後鎖定該模型。最後判斷介面終使否有顯示模型控制手把，如果有就進行銷毀，以確保後續不會同時出現兩個模型控制手把。程式如下所示。

       ```csharp=
        public GameObject model;
        public void btn_OnClick()
        {
            if (model_manager2.model_id != null) model_manager2.model_id.transform.GetComponent<Collider>().enabled = true; //開啟前一個鎖定物體的碰撞器

            GameObject checked_model = Instantiate(model, model.transform.position, Quaternion.identity); //生成新的標註物件
            model_manager2.model_id = checked_model; //鎖定生成的物件

            if (model_manager2.handle_show) //如果把手有顯示就銷毀把手
            {
                Destroy(model_manager2.X_show);
                Destroy(model_manager2.Y_show);
                Destroy(model_manager2.Z_show);
                model_manager2.X_show = null;
                model_manager2.Y_show = null;
                model_manager2.Z_show = null;
            }
        }
       ```
   
   3. **物件控制**
       物件控制腳本主要有平移（Translate）、旋轉（Rotate）、縮放（Scale）、刪除（Delete）、發送（Send）等五項功能，其中平移、旋轉、縮放使用時將顯示相對應之手把，如下圖所示，在程式上透過`model_type`、`X_Axis`、`Y_Axis`、`Z_Axis`等變數讓綁定的按鈕進行相應的設定，按鈕事件綁定詳細可參考[阿旺師磨書坊: Unity 程式設計教學 - 按鈕綁定事件 Button Script 的應用](http://wangwangtc.blogspot.com/2019/07/unity-button-script.html)，其程式如下所示。

       ![物件控制手把](https://i.imgur.com/TPPWEMe.png)

       ```csharp=
        public void btn_OnClick()
        {
            if (model_manager2.handle_show == false) //確認物件移動手把沒有被顯示
            {
                show_handle();
                if (model_type == "T") model_manager2.model_type = 1;
                else if (model_type == "R") model_manager2.model_type = 2;
                else if (model_type == "S") model_manager2.model_type = 3;
            }
            else //如果把手已經顯示
            {
                destroy_handle(); //銷毀上一個把手
                show_handle(); //重新繪製把手
                if (model_type == "T" && model_manager2.model_type != 1)
                {
                    model_manager2.model_type = 1;
                }
                else if (model_type == "R" && model_manager2.model_type != 2)
                {
                    model_manager2.model_type = 2;
                }
                else if (model_type == "S" && model_manager2.model_type != 3)
                {
                    model_manager2.model_type = 3;
                }
            }
        }

        private void show_handle()
        {
            if (model_manager2.model_id != null)
            {
                GameObject model = model_manager2.model_id;

                GameObject X = Instantiate(X_Axis, model.transform.position, model.transform.rotation);
                X.transform.localScale = model.transform.localScale;

                GameObject Y = Instantiate(Y_Axis, model.transform.position, model.transform.rotation);
                Y.transform.localScale = model.transform.localScale;

                GameObject Z = Instantiate(Z_Axis, model.transform.position, model.transform.rotation);
                Z.transform.localScale = model.transform.localScale;

                model_manager2.handle_show = true;
                model_manager2.X_show = X;
                model_manager2.Y_show = Y;
                model_manager2.Z_show = Z;

                model.transform.GetComponent<Collider>().enabled = false; //關閉該物體的碰撞器
            }
        }

        private void destroy_handle()
        {
            Destroy(model_manager2.X_show);
            Destroy(model_manager2.Y_show);
            Destroy(model_manager2.Z_show);
            model_manager2.X_show = null;
            model_manager2.Y_show = null;
            model_manager2.Z_show = null;

            model_manager2.handle_id = null;
        }
       ```

       刪除按鈕則使用`Destroy()`函式將被鎖定的標註物件刪除，並同時清除紀錄鎖定的全域變數`model_manager2.model_id`、以及已經顯示的物件控制手把。

       ```csharp=
        public void distory()
        {
            if (model_manager2.model_id != null)
            {
                Destroy(model_manager2.model_id);
                model_manager2.model_id = null;
                destroy_handle();
            }
        }

        private void destroy_handle()
        {
            Destroy(model_manager2.X_show);
            Destroy(model_manager2.Y_show);
            Destroy(model_manager2.Z_show);
            model_manager2.X_show = null;
            model_manager2.Y_show = null;
            model_manager2.Z_show = null;

            model_manager2.handle_id = null;
        }
       ```
   
       傳送按鈕示將目前已經顯示的標註物件資訊，以XML格式打包後，使用Socket傳送至霧節點進行後續處理，其中XML結構樹狀圖如下所示，其節點意義如下表所示。
       
       ![XML結構樹狀圖](https://i.imgur.com/i9e0qdZ.png)

        |節點|附屬於|內容|
        |:---:|:---:|:---:
        |Annotation_Data|Null|作為整份腳本的母節點
        |<Information>|<Annotation_Data>|紀錄文件的基本資訊
        |<Creator>|<Annotation_Data>/<Information>|創建該文件之人員名稱
        |<Time>|<Annotation_Data>/<Information>|創建該文件的時間
        |<Target>|<Annotation_Data>/<Information>|該文件之目標機台
        |<Model_Data>|<Annotation_Data>|紀錄標註資訊
        |<Number>|<Annotation_Data>/<Model_Data>|紀錄標註物件的順序
        |<Type>|<Annotation_Data>/<Model_Data>/<Number>|標註物件之種類編號
        |<Location>|<Annotation_Data>/<Model_Data>/<Number>|標註物件於機台中的相對位置
        |<Size>|<Annotation_Data>/<Model_Data>/<Number>|標註物件之縮放比例
        |<Rotation Angle>|<Annotation_Data>/<Model_Data>/<Number>|標註物件之旋轉角度
    
        在程式中將使用C＃內建的XML類別進行打包，其中我們將使用標籤（`"Annotation"`）搜尋標註物件，標籤為事先設定在註件中的參數，並將其依序輸入XML物件中，最終將XML內容以字串方式取出後，以UTF-8編碼轉換為Byte格式，以Socket傳送至霧節點進行後續處理，程式如下所示。
    
        ```csharp=
        public void send_model() //發送標註資訊
        {
            GameObject[] model_list;
            model_list = GameObject.FindGameObjectsWithTag("Annotation");

            XmlDocument send_data = new XmlDocument();
            XmlElement annotation_data = send_data.CreateElement("Annotation_Data"); //創建根節點
            send_data.AppendChild(annotation_data); //將跟節點加入至XML物件中

            XmlElement information = send_data.CreateElement("Information"); //創建節點
            annotation_data.AppendChild(information); //將跟節點加入至annotation_data節中

            XmlElement creator = send_data.CreateElement("Creator");
            creator.InnerText = "Hong-Yuan Yang";
            information.AppendChild(creator);

            XmlElement time = send_data.CreateElement("Time");
            time.InnerText = DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss");
            information.AppendChild(time);

            XmlElement target = send_data.CreateElement("Target");
            target.InnerText = "NCKU IMILab CNC";
            information.AppendChild(target);

            XmlElement model_data = send_data.CreateElement("Model_Data");
            annotation_data.AppendChild(model_data);

            int i = 0;
            foreach (GameObject model in model_list)
            {
                string name = model.name;
                Vector3 position = model.transform.transform.position;
                Quaternion rotate = model.transform.rotation;
                Vector3 scale = model.transform.localScale;

                XmlElement number = send_data.CreateElement("Number");
                number.SetAttribute("Number", Convert.ToString(i));//設定屬性
                model_data.AppendChild(number);

                XmlElement type = send_data.CreateElement("Type");
                type.InnerText = model_name2type(name);
                number.AppendChild(type);

                XmlElement location = send_data.CreateElement("Location");
                location.InnerText = Convert.ToString(position);
                number.AppendChild(location);

                XmlElement size = send_data.CreateElement("Size");
                size.InnerText = Convert.ToString(scale);
                number.AppendChild(size);

                XmlElement rotation_angle = send_data.CreateElement("Rotation_Angle");
                rotation_angle.InnerText = Convert.ToString(rotate);
                number.AppendChild(rotation_angle);

                i++;
            }
            send_data.Save(@"Y:\test.xml"); //儲存XML檔

            byte[] send = Encoding.UTF8.GetBytes(send_data.OuterXml);
            model_manager2.clientSocket.Send(send);
        }

        private string model_name2type(string name) //將模型名稱轉換為代號
        {
            string type = "";
            switch (name)
            {
                case "Arrow Variant(Clone)":
                    type = "0";
                    break;

                case "hand2 Variant(Clone)":
                    type = "1";
                    break;

                case "Notice Variant(Clone)":
                    type = "2";
                    break;

                case "Whiteboard Variant(Clone)":
                    type = "3";
                    break;
            }
            return type;
        }
        ```
   
   4. **物件鎖定**
    物件鎖定腳本主要是靠著射線檢測達成，由相機朝著滑鼠點擊的位置方向發射射線，射線會檢測路徑上是否有「碰撞體」物件，所以檢測物件必須是「碰撞體」，若要避開特定物件只需要把該物件的碰撞體關閉即可。本腳本之物件檢測程式碼參考《[How To Detect Mouse Click Or Touch On A GameObject Using C# Script In Unity 3D](https://www.c-sharpcorner.com/article/how-to-detect-mouse-click-or-touch-on-a-gameobject-using-c-sharp-script-in-unity3d/)》，並在檢測物件後，透過物件標籤判斷目前選擇的物件種類進行相對應的操作。程式如下所示。
    
        ```csharp=
        void Update()
        {
            if (Input.GetMouseButtonDown(0) && !EventSystem.current.IsPointerOverGameObject()) //檢測滑鼠左鍵點擊以及是否在UI上
            {
                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
                RaycastHit hitInfo;  

                if (Physics.Raycast(ray, out hitInfo)) //射線有檢測到物體碰撞
                {
                    GameObject check = hitInfo.collider.gameObject;
                    if (check.tag != "Transform" && model_manager2.model_id != null) model_manager2.model_id.transform.GetComponent<Collider>().enabled = true; //開啟該物體的碰撞器

                    if (check != model_manager2.model_id && check.tag != "Transform") //如果點擊的物件跟前一個不一樣
                    {
                        model_manager2.model_type = 0;

                        Destroy(model_manager2.X_show);
                        Destroy(model_manager2.Y_show);
                        Destroy(model_manager2.Z_show);
                        model_manager2.X_show = null;
                        model_manager2.Y_show = null;
                        model_manager2.Z_show = null;

                        model_manager2.handle_show = false;

                        model_manager2.model_id = check;
                    }

                    if (check.tag == "Transform") //如果是選到手把的話
                    {
                        model_manager2.handle_id = check;
                    }
                }
                else //射線沒有檢測到物體
                {
                    if (model_manager2.model_id != null) model_manager2.model_id.transform.GetComponent<Collider>().enabled = true; //開啟該物體的碰撞器

                    model_manager2.model_type = 0;
                    model_manager2.model_id = null;
                    if (model_manager2.handle_show) //如果手把有顯示就將手把銷毀
                    {
                        Destroy(model_manager2.X_show);
                        Destroy(model_manager2.Y_show);
                        Destroy(model_manager2.Z_show);
                        model_manager2.X_show = null;
                        model_manager2.Y_show = null;
                        model_manager2.Z_show = null;

                        model_manager2.handle_show = false;
                    }

                }
            }
        }
        ```
   
   5. **影像視窗控制**
    在本腳本中包含了相機位置控制、標註物件的平移、旋轉、縮放等功能，各個功能皆是透過滑鼠的移動距離進行控制，並透過判別物件移動模式（`model_manager2.model_type`）決定物件如何移動。本腳本程式是基於《[Unity 3D滑鼠操作實現旋轉、縮放觀察物體](https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/513996/)》進行修改，修改後程式如下所示。
    
        ```csharp=
        public Vector3 mousePos1;                           //記錄滑鼠點下去瞬間的位置
        public Vector3 mousePos2;                           //記錄滑鼠任何時刻的位置
        public Quaternion start_qua;                        //角度使用四元數
        public Vector3 start_pos;                           //位置座標
                                                            // Use this for initialization
        void Start()
        {
            //記錄相機開始的角度與位置
            start_qua = transform.rotation;
            start_pos = transform.position;
        }
        // Update is called once per frame
        void Update()
        {
            //記錄滑鼠實時移動的點
            mousePos2 = Input.mousePosition;
        }
        void OnGUI()
        {
            if (model_manager2.model_type == 0)
            {
                //滑鼠左鍵
                if (Input.GetMouseButton(0))
                {
                    mousePos1 = Input.mousePosition;            //記錄滑鼠點選瞬間的點
                    Vector3 offset = mousePos1 - mousePos2;     //記錄滑鼠移動的距離
                                                                //上下與左右 旋轉分開，絕對值比較
                    if (Mathf.Abs(offset.x) > Mathf.Abs(offset.y))
                    {
                        //以物體上方為旋轉軸（Vector3.up == new Vector3(0, 1.0f, 0)），物體左右旋轉角度與滑鼠橫向移動距離相關，變化速率30
                        transform.RotateAround(new Vector3(0, 0, 0), Vector3.up, Time.deltaTime * offset.x * 30);
                    }
                    else
                    {
                        //以世界座標右方為旋轉軸（transform.right，是會變化的量），物體上下旋轉角度與滑鼠縱向移動距離相關，變化速率30
                        transform.RotateAround(new Vector3(0, 0, 0), transform.right, -Time.deltaTime * offset.y * 30);
                    }
                    //列印資料transform.right變數
                    //Debug.Log("pos: " + transform.right);
                }
                //滑鼠中鍵，物體恢復原來的角度與位置
                if (Input.GetMouseButton(2))
                {
                    transform.rotation = start_qua;
                    transform.position = start_pos;
                }
                //滑鼠中鍵滑動，物體縮放，攝像頭前後移動距離範圍在2f~5f，變化速率3f
                if (Input.GetAxis("Mouse ScrollWheel") > 0f)
                {
                    transform.Translate(Vector3.forward * Time.deltaTime * Input.GetAxis("Mouse ScrollWheel") * 20);
                }
                if (Input.GetAxis("Mouse ScrollWheel") < 0f)
                {
                    transform.Translate(Vector3.back * Time.deltaTime * (-Input.GetAxis("Mouse ScrollWheel")) * 20);
                }
            }
            else if (model_manager2.model_type == 1 && model_manager2.handle_id != null) //虛擬物件平移模式
            {

                //滑鼠左鍵
                if (Input.GetMouseButton(0))
                {
                    mousePos1 = Input.mousePosition;            //記錄滑鼠點選瞬間的點
                    Vector3 offset = mousePos1 - mousePos2;     //記錄滑鼠移動的距離

                    if (model_manager2.handle_id == model_manager2.X_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(offset.sqrMagnitude * 0.0005f, 0, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(-offset.sqrMagnitude * 0.0005f, 0, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Y_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(0, offset.sqrMagnitude * 0.0005f, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(0, -offset.sqrMagnitude * 0.0005f, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Z_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(0, 0, -offset.sqrMagnitude * 0.0005f));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(0, 0, offset.sqrMagnitude * 0.0005f));
                        }
                    }
                }
            }
            else if (model_manager2.model_type == 2 && model_manager2.handle_id != null) //虛擬物件旋轉模式
            {

                //滑鼠左鍵
                if (Input.GetMouseButton(0))
                {
                    mousePos1 = Input.mousePosition;            //記錄滑鼠點選瞬間的點
                    Vector3 offset = mousePos1 - mousePos2;     //記錄滑鼠移動的距離

                    if (model_manager2.handle_id == model_manager2.X_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(offset.sqrMagnitude * 0.5f, 0, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(-offset.sqrMagnitude * 0.5f, 0, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Y_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(0, offset.sqrMagnitude * 0.5f, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(0, -offset.sqrMagnitude * 0.5f, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Z_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(0, 0, -offset.sqrMagnitude * 0.5f));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(0, 0, offset.sqrMagnitude * 0.5f));
                        }
                    }
                }
            }
            else if (model_manager2.model_type == 3 && model_manager2.handle_id != null) //虛擬物件縮放模式
            {

                //滑鼠左鍵
                if (Input.GetMouseButton(0))
                {
                    mousePos1 = Input.mousePosition;            //記錄滑鼠點選瞬間的點
                    Vector3 offset = mousePos1 - mousePos2;     //記錄滑鼠移動的距離

                    if (model_manager2.handle_id == model_manager2.X_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(-offset.sqrMagnitude * 0.005f, 0, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(offset.sqrMagnitude * 0.005f, 0, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Y_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(0, offset.sqrMagnitude * 0.005f, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(0, -offset.sqrMagnitude * 0.005f, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Z_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(0, 0, -offset.sqrMagnitude * 0.005f));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(0, 0, offset.sqrMagnitude * 0.005f));
                        }
                    }
                }
            }
        }

        private void model_translate(Vector3 move) //物件平移
        {
            model_manager2.model_id.transform.Translate(move);
            model_manager2.X_show.transform.Translate(move);
            model_manager2.Y_show.transform.Translate(move);
            model_manager2.Z_show.transform.Translate(move);
        }

        private void model_rotate(Vector3 rotate) //物件旋轉
        {
            model_manager2.model_id.transform.Rotate(rotate);
            model_manager2.X_show.transform.Rotate(rotate);
            model_manager2.Y_show.transform.Rotate(rotate);
            model_manager2.Z_show.transform.Rotate(rotate);
        }

        private void model_scale(Vector3 scale) //物件縮放
        {
            model_manager2.model_id.transform.localScale += scale;
            model_manager2.X_show.transform.localScale += scale;
            model_manager2.Y_show.transform.localScale += scale;
            model_manager2.Z_show.transform.localScale += scale;
        }
        ```
   
   6. **Socket Client**
       本腳本主要用以與Socket Server建立連線，用於接收渲染影像以及發送標註物件資訊，為了不讓程式卡死在等待影像回傳，所以將接收影像功能使用多執行續執行，並將影像顯示在`RawImage`物件上。在程式中的Socket連線可參考[2022/05/19 CNC感測資料擷取與可視化（2）的AR系統人機介面](https://hackmd.io/ayU0UBA4Qb-vM6oogoWz4Q#AR%E7%B3%BB%E7%B5%B1%E4%BA%BA%E6%A9%9F%E4%BB%8B%E9%9D%A2)以及[unity開發：TCP socket網路連線](https://www.796t.com/content/1549354143.html)，程式如下所示。
    
        ```csharp=
        public string Server_IP;
        public int Server_PORT;

        private Socket clientSocket; //Socket Client物件
        private Thread threadSocket; //Socket的執行緒

        private GameObject Show_Board;
        private bool get_img = false;
        Mat image = null;

        // Start is called before the first frame update
        void Start()
        {
            Show_Board = GameObject.Find("RawImage_FogShading");

            clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //創建一個Socket物件
            clientSocket.Connect(new IPEndPoint(IPAddress.Parse(Server_IP), Server_PORT)); //連線到Server
            model_manager2.clientSocket = clientSocket;

            threadSocket = new Thread(new ThreadStart(SocketReceive)); //開啟新的執行緒
            threadSocket.Start(); //執行新的執行緒
        }

        // Update is called once per frame
        void Update()
        {
            if (get_img && image != null)
            {
                get_img = false;

                int height = image.Height;
                int width = image.Width;
                Texture2D renderedTexture = new Texture2D(width, height, TextureFormat.RGBA32, true, true); //創建新的2D平面材質
                renderedTexture.LoadImage(image.ImEncode()); //將照片輸入材質

                RawImage show_img = Show_Board.GetComponent<RawImage>(); //取得屬性
                show_img.texture = renderedTexture; //將影像材質輸入
            }
        }

        private void SocketReceive() //接收Server（Fog Node）傳過來的影像
        {
            while (true)
            {
                byte[] data = new byte[2000000];
                int count = clientSocket.Receive(data);

                ImreadModes mode = ImreadModes.Color;
                image = Cv2.ImDecode(data, mode);

                get_img = true;
            }
        }

        void OnApplicationQuit() //程式視窗關閉時執行
        {
            //關閉執行緒
            if (threadSocket != null)
            {
                threadSocket.Interrupt();
                threadSocket.Abort();
            }
            //最後關閉伺服器
            if (clientSocket != null) clientSocket.Close();
        }
        ```

    7. Socket Server
    建置於霧節點的Socket Server主要用於接收來自遠端平台的XML標注資訊，以及AR渲染影像供遠端專家確認標注狀況，建置方式可參考[2022/05/31 霧節點伺服器建置（1）的Socket Server](https://hackmd.io/N_mKpugmTDmJz4M_nzh3VA?view#Socket-Server)。程式可直接參考[程式碼整理](https://hackmd.io/YBJrrhSrSLWTMjuhqslOzg?view#%E7%A8%8B%E5%BC%8F%E7%A2%BC%E6%95%B4%E7%90%86)的Socket Server部分。
    
## 程式碼整理
1. 全域變數
    ```csharp=
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    using System.Net.Sockets; //Socket

    public class model_manager : MonoBehaviour
    {
        // Start is called before the first frame update
        void Start()
        {

        }

        // Update is called once per frame
        void Update()
        {

        }
    }

    static class model_manager2
    {
        //public static bool camera_transform = true;
        public static int model_type = 0; //目前的移動模式（0：移動世界座標、1：模型平移、2：模型旋轉、3：模型縮放）
        public static GameObject model_id = null; //目前鎖定的標註物件
        public static GameObject handle_id = null; //目前鎖定的手把物件
        public static bool handle_show = false; //是否已經顯示物件移動手把
        //public static ArrayList model_list = new ArrayList();

        public static GameObject X_show = null; //目前顯示的手把X軸物件
        public static GameObject Y_show = null; //目前顯示的手把Y軸物件
        public static GameObject Z_show = null; //目前顯示的手把Z軸物件

        public static Socket clientSocket; //Socket Client物件
    }
    ```
    
2. 物件生成
    ```csharp=
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class model_btn_script : MonoBehaviour
    {
        public GameObject model;

        // Start is called before the first frame update
        void Start()
        {

        }

        // Update is called once per frame
        void Update()
        {

        }

        public void btn_OnClick()
        {
            if (model_manager2.model_id != null) model_manager2.model_id.transform.GetComponent<Collider>().enabled = true; //開啟前一個鎖定物體的碰撞器

            GameObject checked_model = Instantiate(model, model.transform.position, Quaternion.identity); //生成新的標註物件
            model_manager2.model_id = checked_model; //鎖定生成的物件
            
            if (model_manager2.handle_show) //如果把手有顯示就銷毀把手
            {
                Destroy(model_manager2.X_show);
                Destroy(model_manager2.Y_show);
                Destroy(model_manager2.Z_show);
                model_manager2.X_show = null;
                model_manager2.Y_show = null;
                model_manager2.Z_show = null;
            }
        }
    }
    ```
    
3. 物件控制
    ```csharp=
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    using System.Xml;
    using System.Xml.Serialization;
    using System;
    using System.Text;

    public class TRS_model : MonoBehaviour
    {
        public string model_type;
        public GameObject X_Axis;
        public GameObject Y_Axis;
        public GameObject Z_Axis;

        // Start is called before the first frame update
        void Start()
        {

        }

        // Update is called once per frame
        void Update()
        {

        }

        private void show_handle()
        {
            if (model_manager2.model_id != null)
            {
                GameObject model = model_manager2.model_id;

                GameObject X = Instantiate(X_Axis, model.transform.position, model.transform.rotation);
                X.transform.localScale = model.transform.localScale;

                GameObject Y = Instantiate(Y_Axis, model.transform.position, model.transform.rotation);
                Y.transform.localScale = model.transform.localScale;

                GameObject Z = Instantiate(Z_Axis, model.transform.position, model.transform.rotation);
                Z.transform.localScale = model.transform.localScale;

                model_manager2.handle_show = true;
                model_manager2.X_show = X;
                model_manager2.Y_show = Y;
                model_manager2.Z_show = Z;

                model.transform.GetComponent<Collider>().enabled = false; //關閉該物體的碰撞器
            }
        }

        private void destroy_handle()
        {
            Destroy(model_manager2.X_show);
            Destroy(model_manager2.Y_show);
            Destroy(model_manager2.Z_show);
            model_manager2.X_show = null;
            model_manager2.Y_show = null;
            model_manager2.Z_show = null;

            model_manager2.handle_id = null;
        }

        public void btn_OnClick()
        {
            if (model_manager2.handle_show == false) //確認物件移動手把沒有被顯示
            {
                show_handle();
                if (model_type == "T") model_manager2.model_type = 1;
                else if (model_type == "R") model_manager2.model_type = 2;
                else if (model_type == "S") model_manager2.model_type = 3;
            }
            else //如果把手已經顯示
            {
                destroy_handle(); //銷毀上一個把手
                show_handle(); //重新繪製把手
                if (model_type == "T" && model_manager2.model_type != 1)
                {
                    model_manager2.model_type = 1;
                }
                else if (model_type == "R" && model_manager2.model_type != 2)
                {
                    model_manager2.model_type = 2;
                }
                else if (model_type == "S" && model_manager2.model_type != 3)
                {
                    model_manager2.model_type = 3;
                }
            }

        }

        public void distory()
        {
            if (model_manager2.model_id != null)
            {
                Destroy(model_manager2.model_id);
                model_manager2.model_id = null;
                destroy_handle();
            }
        }

        public void send_model() //發送標註資訊
        {
            GameObject[] model_list;
            model_list = GameObject.FindGameObjectsWithTag("Annotation");

            XmlDocument send_data = new XmlDocument();
            XmlElement annotation_data = send_data.CreateElement("Annotation_Data");
            send_data.AppendChild(annotation_data);

            XmlElement information = send_data.CreateElement("Information");
            annotation_data.AppendChild(information);

            XmlElement creator = send_data.CreateElement("Creator");
            creator.InnerText = "Hong-Yuan Yang";
            information.AppendChild(creator);

            XmlElement time = send_data.CreateElement("Time");
            time.InnerText = DateTime.Now.ToString("yyyy/MM/dd HH:mm:ss");
            information.AppendChild(time);

            XmlElement target = send_data.CreateElement("Target");
            target.InnerText = "NCKU IMILab CNC";
            information.AppendChild(target);

            XmlElement model_data = send_data.CreateElement("Model_Data");
            annotation_data.AppendChild(model_data);

            int i = 0;
            foreach (GameObject model in model_list)
            {
                string name = model.name;
                Vector3 position = model.transform.transform.position;
                Quaternion rotate = model.transform.rotation;
                Vector3 scale = model.transform.localScale;

                XmlElement number = send_data.CreateElement("Number");
                number.SetAttribute("Number", Convert.ToString(i));//設定屬性
                model_data.AppendChild(number);

                XmlElement type = send_data.CreateElement("Type");
                type.InnerText = model_name2type(name);
                number.AppendChild(type);

                XmlElement location = send_data.CreateElement("Location");
                location.InnerText = Convert.ToString(position);
                number.AppendChild(location);

                XmlElement size = send_data.CreateElement("Size");
                size.InnerText = Convert.ToString(scale);
                number.AppendChild(size);

                XmlElement rotation_angle = send_data.CreateElement("Rotation_Angle");
                rotation_angle.InnerText = Convert.ToString(rotate);
                number.AppendChild(rotation_angle);

                i++;
            }
            send_data.Save(@"Y:\test.xml"); //儲存XML檔

            byte[] send = Encoding.UTF8.GetBytes(send_data.OuterXml);
            model_manager2.clientSocket.Send(send);
        }

        private string model_name2type(string name)
        {
            string type = "";
            switch (name)
            {
                case "Arrow Variant(Clone)":
                    type = "0";
                    break;

                case "hand2 Variant(Clone)":
                    type = "1";
                    break;

                case "Notice Variant(Clone)":
                    type = "2";
                    break;

                case "Whiteboard Variant(Clone)":
                    type = "3";
                    break;
            }
            return type;
        }
    }
    ```
    
4. 物件鎖定
    ```csharp=
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEngine.EventSystems;

    public class model_transform : MonoBehaviour
    {
        // Start is called before the first frame update
        void Start()
        {

        }

        // Update is called once per frame
        void Update()
        {
            if (Input.GetMouseButtonDown(0) && !EventSystem.current.IsPointerOverGameObject()) //檢測滑鼠左鍵點擊以及是否在UI上
            {
                Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
                RaycastHit hitInfo;  

                if (Physics.Raycast(ray, out hitInfo)) //射線有檢測到物體碰撞
                {
                    GameObject check = hitInfo.collider.gameObject;
                    if (check.tag != "Transform" && model_manager2.model_id != null) model_manager2.model_id.transform.GetComponent<Collider>().enabled = true; //開啟該物體的碰撞器

                    if (check != model_manager2.model_id && check.tag != "Transform") //如果點擊的物件跟前一個不一樣
                    {
                        model_manager2.model_type = 0;

                        Destroy(model_manager2.X_show);
                        Destroy(model_manager2.Y_show);
                        Destroy(model_manager2.Z_show);
                        model_manager2.X_show = null;
                        model_manager2.Y_show = null;
                        model_manager2.Z_show = null;

                        model_manager2.handle_show = false;

                        model_manager2.model_id = check;
                    }

                    if (check.tag == "Transform") //如果是選到手把的話
                    {
                        model_manager2.handle_id = check;
                    }
                }
                else //射線沒有檢測到物體
                {
                    if (model_manager2.model_id != null) model_manager2.model_id.transform.GetComponent<Collider>().enabled = true; //開啟該物體的碰撞器

                    model_manager2.model_type = 0;
                    model_manager2.model_id = null;
                    if (model_manager2.handle_show) //如果手把有顯示就將手把銷毀
                    {
                        Destroy(model_manager2.X_show);
                        Destroy(model_manager2.Y_show);
                        Destroy(model_manager2.Z_show);
                        model_manager2.X_show = null;
                        model_manager2.Y_show = null;
                        model_manager2.Z_show = null;

                        model_manager2.handle_show = false;
                    }

                }
            }
        }
    }
    ```
    
5. 影像視窗控制
    ```csharp=
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;

    public class control_camera_view : MonoBehaviour
    {
        public Vector3 mousePos1;                           //記錄滑鼠點下去瞬間的位置
        public Vector3 mousePos2;                           //記錄滑鼠任何時刻的位置
        public Quaternion start_qua;                        //角度使用四元數
        public Vector3 start_pos;                           //位置座標
                                                            // Use this for initialization
        void Start()
        {
            //記錄相機開始的角度與位置
            start_qua = transform.rotation;
            start_pos = transform.position;
        }
        // Update is called once per frame
        void Update()
        {
            //記錄滑鼠實時移動的點
            mousePos2 = Input.mousePosition;
        }
        void OnGUI()
        {
            if (model_manager2.model_type == 0)
            {
                //滑鼠左鍵
                if (Input.GetMouseButton(0))
                {
                    mousePos1 = Input.mousePosition;            //記錄滑鼠點選瞬間的點
                    Vector3 offset = mousePos1 - mousePos2;     //記錄滑鼠移動的距離
                                                                //上下與左右 旋轉分開，絕對值比較
                    if (Mathf.Abs(offset.x) > Mathf.Abs(offset.y))
                    {
                        //以物體上方為旋轉軸（Vector3.up == new Vector3(0, 1.0f, 0)），物體左右旋轉角度與滑鼠橫向移動距離相關，變化速率30
                        transform.RotateAround(new Vector3(0, 0, 0), Vector3.up, Time.deltaTime * offset.x * 30);
                    }
                    else
                    {
                        //以世界座標右方為旋轉軸（transform.right，是會變化的量），物體上下旋轉角度與滑鼠縱向移動距離相關，變化速率30
                        transform.RotateAround(new Vector3(0, 0, 0), transform.right, -Time.deltaTime * offset.y * 30);
                    }
                    //列印資料transform.right變數
                    //Debug.Log("pos: " + transform.right);
                }
                //滑鼠中鍵，物體恢復原來的角度與位置
                if (Input.GetMouseButton(2))
                {
                    transform.rotation = start_qua;
                    transform.position = start_pos;
                }
                //滑鼠中鍵滑動，物體縮放，攝像頭前後移動距離範圍在2f~5f，變化速率3f
                if (Input.GetAxis("Mouse ScrollWheel") > 0f)
                {
                    transform.Translate(Vector3.forward * Time.deltaTime * Input.GetAxis("Mouse ScrollWheel") * 20);
                }
                if (Input.GetAxis("Mouse ScrollWheel") < 0f)
                {
                    transform.Translate(Vector3.back * Time.deltaTime * (-Input.GetAxis("Mouse ScrollWheel")) * 20);
                }
            }
            else if (model_manager2.model_type == 1 && model_manager2.handle_id != null) //虛擬物件平移模式
            {

                //滑鼠左鍵
                if (Input.GetMouseButton(0))
                {
                    mousePos1 = Input.mousePosition;            //記錄滑鼠點選瞬間的點
                    Vector3 offset = mousePos1 - mousePos2;     //記錄滑鼠移動的距離

                    if (model_manager2.handle_id == model_manager2.X_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(offset.sqrMagnitude * 0.0005f, 0, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(-offset.sqrMagnitude * 0.0005f, 0, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Y_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(0, offset.sqrMagnitude * 0.0005f, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(0, -offset.sqrMagnitude * 0.0005f, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Z_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(0, 0, -offset.sqrMagnitude * 0.0005f));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_translate(new Vector3(0, 0, offset.sqrMagnitude * 0.0005f));
                        }
                    }
                }
            }
            else if (model_manager2.model_type == 2 && model_manager2.handle_id != null) //虛擬物件旋轉模式
            {

                //滑鼠左鍵
                if (Input.GetMouseButton(0))
                {
                    mousePos1 = Input.mousePosition;            //記錄滑鼠點選瞬間的點
                    Vector3 offset = mousePos1 - mousePos2;     //記錄滑鼠移動的距離

                    if (model_manager2.handle_id == model_manager2.X_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(offset.sqrMagnitude * 0.5f, 0, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(-offset.sqrMagnitude * 0.5f, 0, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Y_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(0, offset.sqrMagnitude * 0.5f, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(0, -offset.sqrMagnitude * 0.5f, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Z_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(0, 0, -offset.sqrMagnitude * 0.5f));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_rotate(new Vector3(0, 0, offset.sqrMagnitude * 0.5f));
                        }
                    }
                }
            }
            else if (model_manager2.model_type == 3 && model_manager2.handle_id != null) //虛擬物件縮放模式
            {

                //滑鼠左鍵
                if (Input.GetMouseButton(0))
                {
                    mousePos1 = Input.mousePosition;            //記錄滑鼠點選瞬間的點
                    Vector3 offset = mousePos1 - mousePos2;     //記錄滑鼠移動的距離

                    if (model_manager2.handle_id == model_manager2.X_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(-offset.sqrMagnitude * 0.005f, 0, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(offset.sqrMagnitude * 0.005f, 0, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Y_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(0, offset.sqrMagnitude * 0.005f, 0));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(0, -offset.sqrMagnitude * 0.005f, 0));
                        }
                    }
                    else if (model_manager2.handle_id == model_manager2.Z_show)
                    {
                        if (mousePos1.sqrMagnitude > mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(0, 0, -offset.sqrMagnitude * 0.005f));
                        }
                        else if (mousePos1.sqrMagnitude < mousePos2.sqrMagnitude)
                        {
                            model_scale(new Vector3(0, 0, offset.sqrMagnitude * 0.005f));
                        }
                    }
                }
            }
        }

        private void model_translate(Vector3 move)
        {
            model_manager2.model_id.transform.Translate(move);
            model_manager2.X_show.transform.Translate(move);
            model_manager2.Y_show.transform.Translate(move);
            model_manager2.Z_show.transform.Translate(move);
        }

        private void model_rotate(Vector3 rotate)
        {
            model_manager2.model_id.transform.Rotate(rotate);
            model_manager2.X_show.transform.Rotate(rotate);
            model_manager2.Y_show.transform.Rotate(rotate);
            model_manager2.Z_show.transform.Rotate(rotate);
        }

        private void model_scale(Vector3 scale)
        {
            model_manager2.model_id.transform.localScale += scale;
            model_manager2.X_show.transform.localScale += scale;
            model_manager2.Y_show.transform.localScale += scale;
            model_manager2.Z_show.transform.localScale += scale;
        }
    }
    ```
    
6. Socket Client
    ```csharp=
    using System.Collections;
    using System.Collections.Generic;
    using UnityEngine;
    using UnityEngine.UI;

    using System.Net; //Socket
    using System.Net.Sockets; //Socket
    using System.Threading; //多執行緒
    using System.Text;

    using OpenCvSharp;

    public class Socket_TCP_Client : MonoBehaviour
    {
        public string Server_IP;
        public int Server_PORT;

        private Socket clientSocket; //Socket Client物件
        private Thread threadSocket; //Socket的執行緒

        private GameObject Show_Board;
        private bool get_img = false;
        Mat image = null;

        // Start is called before the first frame update
        void Start()
        {
            Show_Board = GameObject.Find("RawImage_FogShading");

            clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); //創建一個Socket物件
            clientSocket.Connect(new IPEndPoint(IPAddress.Parse(Server_IP), Server_PORT)); //連線到Server
            model_manager2.clientSocket = clientSocket;

            threadSocket = new Thread(new ThreadStart(SocketReceive));
            threadSocket.Start();
        }

        // Update is called once per frame
        void Update()
        {
            if (get_img && image != null)
            {
                get_img = false;
                /* 查看影像是否正常輸入
                Cv2.ImShow("From Socket Server2", image);
                Cv2.WaitKey(0);
                */
                int height = image.Height;
                int width = image.Width;
                Texture2D renderedTexture = new Texture2D(width, height, TextureFormat.RGBA32, true, true);
                renderedTexture.LoadImage(image.ImEncode());

                RawImage show_img = Show_Board.GetComponent<RawImage>();
                show_img.texture = renderedTexture;
            }
        }

        private void SocketReceive() //接收Server（Fog Node）傳過來的影像
        {
            while (true)
            {
                byte[] data = new byte[2000000];
                int count = clientSocket.Receive(data);

                ImreadModes mode = ImreadModes.Color;
                image = Cv2.ImDecode(data, mode);
                /* 查看影像是否正常輸入
                Cv2.ImShow("From Socket Server", image);
                Cv2.WaitKey(0);
                */

                get_img = true;
            }
        }

        void OnApplicationQuit()
        {
            //關閉執行緒
            if (threadSocket != null)
            {
                threadSocket.Interrupt();
                threadSocket.Abort();
            }
            //最後關閉伺服器
            if (clientSocket != null) clientSocket.Close();
        }
    }
    ```
    
    7. Socket Server
    ```python=
    import os
    import io
    import socket
    import cv2
    import numpy as np
    from PIL import Image
    from multiprocessing import Process
    from xml.etree import ElementTree as ET
    from xml.dom import minidom
    from threading import Thread

    class Socket_Server(Process): #給平版用的
        def __init__(self, queue1, queue2, queue3, IP, PORT):
            super(Socket_Server, self).__init__() #需要繼承父類別的的東東

            self.queue1 = queue1
            self.queue2 = queue2
            self.queue3 = queue3

            self.IP = IP
            self.PORT = PORT

            self.server_init()

        def server_init(self):
            self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.s.bind((self.IP, self.PORT))
            self.s.listen(5)

        def bytes2img(self, indata):
            data = np.frombuffer(indata, dtype='uint8')
            try:
                image = Image.open(io.BytesIO(data))
                open_cv_image = np.array(image) 
                open_cv_image = open_cv_image[:, :, ::-1].copy() 
                self.open_cv_image2 = open_cv_image
            except:
                open_cv_image = self.open_cv_image2

            if open_cv_image is not None:
                self.queue1.put(open_cv_image)

        def img2bytes(self):
            img = self.queue2.get(True)

            img_encode = cv2.imencode('.jpg', img)[1]
            data_encode = np.array(img_encode)
            str_encode = data_encode.tobytes()

            return str_encode

        def run(self):
            print("Socket_Server: {}".format(os.getpid()))
            while 1:
                conn, addr = self.s.accept()
                print('Connected by ' + str(addr))

                while 1:
                    indata = conn.recv(2000000)
                    self.bytes2img(indata)            
                    outdata = self.img2bytes()
                    self.queue3.put(outdata)
                    conn.send(outdata)

    class Socket_Server2(Process): #給遠端平台用的
        def __init__(self, queue1, queue2, IP, PORT):
            super(Socket_Server2, self).__init__() #需要繼承父類別的的東東

            self.queue1 = queue1
            self.queue2 = queue2

            self.IP = IP
            self.PORT = PORT

            self.server_init()

        def server_init(self):
            self.s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.s.bind((self.IP, self.PORT))
            self.s.listen(5)

        def bytes2xml(self, indata):
            data = indata.decode("utf-8")

            xml = minidom.parseString(data)
            xml_pretty_str = xml.toprettyxml()

            data = ET.ElementTree(ET.fromstring(xml_pretty_str))
            data.write("test_python.xml")
            self.queue2.put(data)

        def img2bytes(self):
            img = self.queue1.get(True)
            img_encode = cv2.imencode('.jpg', img)[1]
            data_encode = np.array(img_encode)
            str_encode = data_encode.tobytes()

            return str_encode

        def run(self):
            print("Socket_Server2: {}".format(os.getpid()))
            while 1:
                conn, addr = self.s.accept()
                print('Connected by ' + str(addr))

                while 1:
                    outdata = self.queue1.get(True)
                    conn.send(outdata)
    ```
    
## Reference
[Unity3D游戏设计与开发](https://www.books.com.tw/products/CN11698389)
[3d_palm model](https://www.turbosquid.com/3d-models/3d-palm-model/268623)
[Unity基本功(4) – 物件移動&縮放 - 羽毛的電玩新手村](https://featherchung.wordpress.com/2017/07/05/unity%E5%9F%BA%E6%9C%AC%E5%8A%9F4-%E7%89%A9%E4%BB%B6%E7%A7%BB%E5%8B%95%E7%B8%AE%E6%94%BE/)
[Unity 3D滑鼠操作實現旋轉、縮放觀察物體](https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/513996/)
[阿旺師磨書坊: Unity 程式設計教學 - 按鈕綁定事件 Button Script 的應用](http://wangwangtc.blogspot.com/2019/07/unity-button-script.html)
[unity 抓取物件(GameObject)和元件(Component)](https://www.gameislearning.url.tw/article_content.php?getb=30&foog=9997)
[unity 如何获取button文本的内容](https://m.html.cn/softprog/other/11384307002625.html)
[【Unity 新手筆記】取得/改變物件位置](https://ginablog.pixnet.net/blog/post/126701415-%E3%80%90unity-%E6%96%B0%E6%89%8B%E7%AD%86%E8%A8%98%E3%80%91%E5%8F%96%E5%BE%97-%E6%94%B9%E8%AE%8A%E7%89%A9%E4%BB%B6%E4%BD%8D%E7%BD%AE%E5%8F%8A%E8%A7%92%E5%BA%A6)
[[Unity] 滑鼠鍵盤觸發事件、滑鼠拖曳2D物件](https://spursgogo.wordpress.com/2019/03/15/unity-%E6%BB%91%E9%BC%A0%E9%8D%B5%E7%9B%A4%E8%A7%B8%E7%99%BC%E4%BA%8B%E4%BB%B6%E3%80%81%E6%BB%91%E9%BC%A0%E6%8B%96%E6%9B%B32d%E7%89%A9%E4%BB%B6/)
[【問題】使用滑鼠移動,旋轉,縮放物件](https://forum.gamer.com.tw/C.php?bsn=60602&snA=3691)
[Unity基礎教學：全域變數的存取](https://about1005.blogspot.com/2017/06/unity.html)
[How To Detect Mouse Click Or Touch On A GameObject Using C# Script In Unity 3D](https://www.c-sharpcorner.com/article/how-to-detect-mouse-click-or-touch-on-a-gameobject-using-c-sharp-script-in-unity3d/)
[9.unity物件偵測(碰撞Collider2D)](https://ithelp.ithome.com.tw/articles/10261685)
[Unity 動態產生物件](https://oblivious9.pixnet.net/blog/post/80628693-unity-%E5%8B%95%E6%85%8B%E7%94%A2%E7%94%9F%E7%89%A9%E4%BB%B6)
[unity Instantiate实例化物体后出现scale改变](https://blog.csdn.net/weixin_34387284/article/details/93511845)
[unity UGUI之Button按钮多种触发方式实现（有参无参函数）](https://blog.csdn.net/qq_30454411/article/details/79694777)
[Unity腳本：使用 Destroy 摧毀物件或元件](https://www.victsao.com/blog/97-unity/428-unity-script-destroy)
[Unity UI - Blocking clicks](https://www.youtube.com/watch?v=EVZiv7DLU6E)
[Unity 怎么用代码设置物体的碰撞体失效，就是相当于把collider的勾去掉](https://bbs.csdn.net/topics/392301301)
[[unity3d]如何實現遊戲物件跟隨滑鼠方向移動](https://iter01.com/421926.html)
[unity 按鍵控制物件移動和旋轉](https://www.gameislearning.url.tw/article_content.php?getb=32&foog=9997)
[How to change scale of a GameObject in run-time ?](https://forum.unity.com/threads/how-to-change-scale-of-a-gameobject-in-run-time.109705/)
[Unity3D(通过Tag 标签查找物体)](https://blog.csdn.net/weixin_41801281/article/details/82291774)
[[C#.NET][XML] XML檔案基本操作-XmlDocument](https://dotblogs.com.tw/yc421206/2010/08/10/17108)
[Unity 網路連線───使用Socket](https://oblivious9.pixnet.net/blog/post/203484322-unity-%E7%B6%B2%E8%B7%AF%E9%80%A3%E7%B7%9A%E2%94%80%E2%94%80%E2%94%80%E4%BD%BF%E7%94%A8socket)
[Unity C# Thread 注意事項](https://oblivious9.pixnet.net/blog/post/204439375-Unity%20C#%20Thread%20%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A0%85)
[unity開發：TCP socket網路連線](https://www.796t.com/content/1549354143.html)
[UNITY-GetComponent基礎應用-UI圖片切換](https://home.gamer.com.tw/creationDetail.php?sn=4877145)
[把 OpenCVSharp4 安裝進 Unity （含 Webcam 測試程式）](https://medium.com/@frank1314168/%E5%B0%87-opencvsharp4-%E8%A3%9D%E9%80%B2-unity-8906cb8f9543)
[RawImage.texture](https://docs.unity3d.com/cn/2018.4/ScriptReference/UI.RawImage-texture.html)
[Convert Unity Texture2D to OpenCVSharp Mat](https://kobazlab.tech/2020/08/22/convert-opencvsharp-mat-to-unity-texture2d/)